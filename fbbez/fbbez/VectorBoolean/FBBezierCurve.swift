//
//  FBBezierCurve.swift
//  Swift VectorBoolean for iOS
//
//  Based on FBBezierCurve - Created by Andrew Finnell on 6/6/11.
//  Copyright 2011 Fortunate Bear, LLC. All rights reserved.
//
//  Created by Leslie Titze on 2015-05-21.
//  Copyright (c) 2015 Leslie Titze. All rights reserved.
//

// FBBezierCurve is one cubic 2D bezier curve.
// It represents one segment of a bezier path, and is where
// the intersection calculation happens

import UIKit


// MARK ---- Normalized Line ----

struct FBNormalizedLine {
  var a : Double // * x +
  var b : Double // * y +
  var c : Double // constant


  init(a: Double, b : Double, c : Double) {
    self.a = a
    self.b = b
    self.c = c
  }

  // 30
  //static FBNormalizedLine FBNormalizedLineMake(NSPoint point1, NSPoint point2)
  // Create a normalized line such that computing the distance from it is quick.
  //  See:    http://softsurfer.com/Archive/algorithm_0102/algorithm_0102.htm#Distance%20to%20an%20Infinite%20Line
  //          http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/geometry/basic.html
  //
  init(point1: CGPoint, point2: CGPoint) {
    self.a = Double(point1.y - point2.y)
    self.b = Double(point2.x - point1.x)
    self.c = Double(point1.x * point2.y - point2.x * point1.y)

    let distance = sqrt(self.b * self.b + self.a * self.a)

    // GPC: prevent divide-by-zero from putting NaNs into the values which cause trouble further on. I'm not sure
    // what cases trigger this, but sometimes point1 == point2 so distance is 0.
    if distance != 0.0 {
      self.a /= distance
      self.b /= distance
      self.c /= distance
    } else {
      self.a = 0
      self.b = 0
      self.c = 0
    }
  }

  // 53
  //static FBNormalizedLine FBNormalizedLineOffset(FBNormalizedLine line, CGFloat offset)
  func copyWithOffset(_ offset: Double) -> FBNormalizedLine
  {
    return FBNormalizedLine(
      a: self.a,
      b: self.b,
      c: self.c + offset)
  }

  // 59
  // static CGFloat FBNormalizedLineDistanceFromPoint(FBNormalizedLine line, NSPoint point)
  func distanceFromPoint(_ point: CGPoint) -> Double
  {
    return a * Double(point.x) + b * Double(point.y) + c;
  }

  // 64
  //static NSPoint FBNormalizedLineIntersection(FBNormalizedLine line1, FBNormalizedLine line2)
  func intersectionWith(_ other: FBNormalizedLine) -> CGPoint
  {
    let denominator = (self.a * other.b) - (other.a * self.b)

    return CGPoint(
      x: (self.b * other.c - other.b * self.c) / denominator,
      y: (self.a * other.c - other.a * self.c) / denominator)
  }
}


// ========================================================
// MARK: ---- Helper Functions
// ========================================================


func FBParameterOfPointOnLine(_ lineStart: CGPoint, lineEnd: CGPoint, point: CGPoint) -> Double {

  // Note: its asumed you have already checked that point is colinear with the line (lineStart, lineEnd)

  let lineLength = FBDistanceBetweenPoints(lineStart, point2: lineEnd)
  let lengthFromStart = FBDistanceBetweenPoints(point, point2: lineStart)
  var parameter = lengthFromStart / lineLength

  // The only tricky thing here is the sign. Is the point _before_ lineStart, or after lineStart?
  let lengthFromEnd = FBDistanceBetweenPoints(point, point2: lineEnd)
  if FBAreValuesClose(lineLength + lengthFromStart, value2: lengthFromEnd) {
    parameter = -parameter
  }

  return parameter
}

// FBLinesIntersect Usage:
// var intersectAt = CGPoint(x:0,y:0)
// var boolGotit = FBLinesIntersect(p1,p2,p3,p4,&intersectAt)

func FBLinesIntersect(_ line1Start: CGPoint, line1End: CGPoint, line2Start: CGPoint, line2End: CGPoint, outIntersect: inout CGPoint) -> Bool
{
  let line1 = FBNormalizedLine(point1: line1Start, point2: line1End)
  let line2 = FBNormalizedLine(point1: line2Start, point2: line2End)
  outIntersect = line1.intersectionWith(line2)
  if outIntersect.x.isNaN || outIntersect.y.isNaN {
    return false
  }
  outIntersect.y = -outIntersect.y
  return true
}

/// The three points are a counter-clockwise turn if the return value is greater than 0,
///  clockwise if less than 0, or colinear if 0.
func CounterClockwiseTurn(_ point1: CGPoint, point2: CGPoint, point3: CGPoint) -> Double
{
  // We're calculating the signed area of the triangle formed by the three points. Well,
  //  almost the area of the triangle -- we'd need to divide by 2. But since we only
  //  care about the direction (i.e. the sign) dividing by 2 is an unnecessary step.
  // See http://mathworld.wolfram.com/TriangleArea.html for the signed area of a triangle.

  let xDeltaA = Double(point2.x - point1.x)
  let yDeltaB = Double(point3.y - point1.y)
  let yDeltaC = Double(point2.y - point1.y)
  let xDeltaD = Double(point3.x - point1.x)

  return xDeltaA * yDeltaB - yDeltaC * xDeltaD
}


/// Calculate if and where the given line intersects the horizontal line at y.
func LineIntersectsHorizontalLine(_ startPoint: CGPoint, endPoint: CGPoint, y: Double, intersectPoint: inout CGPoint) -> Bool {
  // Do a quick test to see if y even falls on the startPoint,endPoint line
  let minY = Double(min(startPoint.y, endPoint.y))
  let maxY = Double(max(startPoint.y, endPoint.y))
  if (y < minY && !FBAreValuesClose(y, value2: minY)) || (y > maxY && !FBAreValuesClose(y, value2: maxY)) {
    return false
  }

  // There's an intersection here somewhere
  if startPoint.x == endPoint.x {
    intersectPoint = CGPoint(x: startPoint.x, y: CGFloat(y))
  }
  else {
    let slope = Double(endPoint.y - startPoint.y) / Double(endPoint.x - startPoint.x)
    intersectPoint = CGPoint(
      x: CGFloat((y - Double(startPoint.y)) / slope) + startPoint.x,
      y: CGFloat(y))
  }

  return true
}

// 134
/// Calculate a point on the bezier curve passed in, specifically the point at parameter.
func BezierWithPoints(_ degree: Int, bezierPoints: [CGPoint], parameter: Double, withCurves: Bool) -> (point: CGPoint, leftCurve: [CGPoint]?, rightCurve: [CGPoint]?) {

  //  We're using De Casteljau's algorithm, which not only calculates the point at parameter
  //  in a numerically stable way, it also computes the two resulting bezier curves that
  //  would be formed if the original were split at the parameter specified.
  //
  // See: http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/de-casteljau.html
  //  for an explaination of De Casteljau's algorithm.

  // bezierPoints, leftCurve, rightCurve will have a length of degree + 1.
  // degree is the order of the bezier path, which will be cubic (3) most of the time.

  // With this algorithm we start out with the points in the bezier path.
  var points : [CGPoint] = [] // we assume we'll never get more than a cubic bezier

  for i in 0 ... degree {
    points.append(bezierPoints[i])
  }

  var leftArray = [CGPoint](repeating: CGPoint.zero, count: degree+1)
  var rightArray = [CGPoint](repeating: CGPoint.zero, count: degree+1)

  // If the caller is asking for the resulting bezier curves, start filling those in
  if withCurves {
    leftArray[0] = points[0]
    rightArray[degree] = points[degree]
  }

  for k in 1 ... degree {
    for i in 0 ... (degree - k) {
      let pxV = (1.0 - parameter) * Double(points[i].x) + parameter * Double(points[i + 1].x)
      points[i].x = CGFloat(pxV)
      let pyV = (1.0 - parameter) * Double(points[i].y) + parameter * Double(points[i + 1].y)
      points[i].y = CGFloat(pyV)
    }
    if withCurves {
      leftArray[k] = points[0]
      rightArray[degree-k] = points[degree-k]
    }
  }

  // The point in the curve at parameter ends up in points[0]
  return (point: points[0], leftCurve: leftArray, rightCurve: rightArray)
}

// 174
func FBComputeCubicFirstDerivativeRoots(_ a: Double, b: Double, c: Double, d: Double) -> [Double]
{
  // See http://processingjs.nihongoresources.com/bezierinfo/#bounds for where the formulas come from

  let denominator = -a + 3.0 * b - 3.0 * c + d

  // If denominator == 0, fall back to
  if FBAreValuesClose(denominator, value2: 0.0) {
    let t = (a - b) / (2.0 * (a - 2.0 * b + c))
    return [t];
  }

  let numeratorLeft = -a + 2.0 * b - c

  let v1 = -a * (c - d)
  let v2 = b * b
  let v3 = b * (c + d)
  let v4 = c * c
  let numeratorRight = -1.0 * sqrt(v1 + v2 - v3 + v4)

  let t1 = (numeratorLeft + numeratorRight) / denominator
  let t2 = (numeratorLeft - numeratorRight) / denominator
  // NOTE: This should be changed to return a tuple
  return [t1, t2]
}

/// Legendre-Gauss abscissae (xi values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
let FBLegendreGaussAbscissaeValues : [[Double]] = [
  [], [],
  [-0.5773502691896257310588680411456152796745, 0.5773502691896257310588680411456152796745],
  [0.0000000000000000000000000000000000000000, -0.7745966692414834042779148148838430643082, 0.7745966692414834042779148148838430643082],
  [-0.3399810435848562573113440521410666406155, 0.3399810435848562573113440521410666406155, -0.8611363115940525725378051902225706726313, 0.8611363115940525725378051902225706726313],
  [0.0000000000000000000000000000000000000000, -0.5384693101056831077144693153968546539545, 0.5384693101056831077144693153968546539545, -0.9061798459386639637003213465504813939333, 0.9061798459386639637003213465504813939333],
  [0.6612093864662644815410885712481103837490, -0.6612093864662644815410885712481103837490, -0.2386191860831969047129774708082550205290, 0.2386191860831969047129774708082550205290, -0.9324695142031520500580654697841964662075, 0.9324695142031520500580654697841964662075],
  [0.0000000000000000000000000000000000000000, 0.4058451513773971841558818596240598708391, -0.4058451513773971841558818596240598708391, -0.7415311855993944600839995473506860435009, 0.7415311855993944600839995473506860435009, -0.9491079123427584862682238053821492940187, 0.9491079123427584862682238053821492940187],
  [-0.1834346424956498078362443493460887111723, 0.1834346424956498078362443493460887111723, -0.5255324099163289908176466269651427865028, 0.5255324099163289908176466269651427865028, -0.7966664774136267279658341067261062562466, 0.7966664774136267279658341067261062562466, -0.9602898564975362871720676594122778624296, 0.9602898564975362871720676594122778624296],
  [0.0000000000000000000000000000000000000000, -0.8360311073266357695388251158874481916428, 0.8360311073266357695388251158874481916428, -0.9681602395076260858530758923734538257122, 0.9681602395076260858530758923734538257122, -0.3242534234038089158147499801998492330313, 0.3242534234038089158147499801998492330313, -0.6133714327005903577116896485676988959312, 0.6133714327005903577116896485676988959312],
  [-0.1488743389816312157059030596428783610463, 0.1488743389816312157059030596428783610463, -0.4333953941292472133994806426926515996456, 0.4333953941292472133994806426926515996456, -0.6794095682990244355892173189204186201096, 0.6794095682990244355892173189204186201096, -0.8650633666889845363456856830453034490347, 0.8650633666889845363456856830453034490347, -0.9739065285171717434309357486199587583542, 0.9739065285171717434309357486199587583542],
  [0.0000000000000000000000000000000000000000, -0.2695431559523449593918087430211016908288, 0.2695431559523449593918087430211016908288, -0.5190961292068118071441062966187018901110, 0.5190961292068118071441062966187018901110, -0.7301520055740493564400139803183265030384, 0.7301520055740493564400139803183265030384, -0.8870625997680953167545681026240345090628, 0.8870625997680953167545681026240345090628, -0.9782286581460569729884468870295677334070, 0.9782286581460569729884468870295677334070],
  [-0.1252334085114689132822718420356977730989, 0.1252334085114689132822718420356977730989, -0.3678314989981801841345543380157323554158, 0.3678314989981801841345543380157323554158, -0.5873179542866174829285341729701030999422, 0.5873179542866174829285341729701030999422, -0.7699026741943046925342741815256886184216, 0.7699026741943046925342741815256886184216, -0.9041172563704749087776235683122649788857, 0.9041172563704749087776235683122649788857, -0.9815606342467192435563561048184055835009, 0.9815606342467192435563561048184055835009],
  [0.0000000000000000000000000000000000000000, -0.2304583159551348015003924274424207396805, 0.2304583159551348015003924274424207396805, -0.4484927510364468683512484403763664886355, 0.4484927510364468683512484403763664886355, -0.6423493394403402279024817289609927684069, 0.6423493394403402279024817289609927684069, -0.8015780907333098781464286730624735355377, 0.8015780907333098781464286730624735355377, -0.9175983992229779229177211163914762437344, 0.9175983992229779229177211163914762437344, -0.9841830547185881350458203087328001856804, 0.9841830547185881350458203087328001856804],
  [-0.1080549487073436676354276642086915671825, 0.1080549487073436676354276642086915671825, -0.3191123689278897446186533670697826892138, 0.3191123689278897446186533670697826892138, -0.5152486363581540995681962158414535224438, 0.5152486363581540995681962158414535224438, -0.6872929048116854788830210054584313184023, 0.6872929048116854788830210054584313184023, -0.8272013150697650196718768711434677243233, 0.8272013150697650196718768711434677243233, -0.9284348836635735180422557277779560536146, 0.9284348836635735180422557277779560536146, -0.9862838086968123141318187663273420184851, 0.9862838086968123141318187663273420184851],
  [0.0000000000000000000000000000000000000000, -0.2011940939974345143870237961891689337790, 0.2011940939974345143870237961891689337790, -0.3941513470775633853904196257644798606634, 0.3941513470775633853904196257644798606634, -0.5709721726085388304738899023504927754402, 0.5709721726085388304738899023504927754402, -0.7244177313601700696210627938853576779366, 0.7244177313601700696210627938853576779366, -0.8482065834104272061821916395274456590414, 0.8482065834104272061821916395274456590414, -0.9372733924007059513883177714888006448746, 0.9372733924007059513883177714888006448746, -0.9879925180204853774057482951320707798004, 0.9879925180204853774057482951320707798004],
  [-0.0950125098376374405129141109682677779347, 0.0950125098376374405129141109682677779347, -0.2816035507792589154263396267197094857693, 0.2816035507792589154263396267197094857693, -0.4580167776572273696800152720243204385042, 0.4580167776572273696800152720243204385042, -0.6178762444026437705701937375124543905258, 0.6178762444026437705701937375124543905258, -0.7554044083550029986540153004170861095190, 0.7554044083550029986540153004170861095190, -0.8656312023878317551961458775622304528952, 0.8656312023878317551961458775622304528952, -0.9445750230732326002680565579794347286224, 0.9445750230732326002680565579794347286224, -0.9894009349916499385102497399202547967434, 0.9894009349916499385102497399202547967434],
  [0.0000000000000000000000000000000000000000, -0.1784841814958478545261044700964703224599, 0.1784841814958478545261044700964703224599, -0.3512317634538763000406902392569463700056, 0.3512317634538763000406902392569463700056, -0.5126905370864769384553483178024180233479, 0.5126905370864769384553483178024180233479, -0.6576711592166907260903485621383879333735, 0.6576711592166907260903485621383879333735, -0.7815140038968013680431567991035990417004, 0.7815140038968013680431567991035990417004, -0.8802391537269859123071569229068700224161, 0.8802391537269859123071569229068700224161, -0.9506755217687677950166857954172883182764, 0.9506755217687677950166857954172883182764, -0.9905754753144173641032921295845881104469, 0.9905754753144173641032921295845881104469],
  [-0.0847750130417353059408824833553808275610, 0.0847750130417353059408824833553808275610, -0.2518862256915054831374334298743633553386, 0.2518862256915054831374334298743633553386, -0.4117511614628426297457508553634397685528, 0.4117511614628426297457508553634397685528, -0.5597708310739475390249708652845583856106, 0.5597708310739475390249708652845583856106, -0.6916870430603532238222896921797655522823, 0.6916870430603532238222896921797655522823, -0.8037049589725231424353069087374024093151, 0.8037049589725231424353069087374024093151, -0.8926024664975557021406871172075625509024, 0.8926024664975557021406871172075625509024, -0.9558239495713977129653926567698363214731, 0.9558239495713977129653926567698363214731, -0.9915651684209308980300079383596312254667, 0.9915651684209308980300079383596312254667],
  [0.0000000000000000000000000000000000000000, -0.1603586456402253668240831530056311748922, 0.1603586456402253668240831530056311748922, -0.3165640999636298302810644145210972055793, 0.3165640999636298302810644145210972055793, -0.4645707413759609383241411251219687983394, 0.4645707413759609383241411251219687983394, -0.6005453046616809897884081692609470337629, 0.6005453046616809897884081692609470337629, -0.7209661773352293856476080691209062933922, 0.7209661773352293856476080691209062933922, -0.8227146565371428188484514976153150200844, 0.8227146565371428188484514976153150200844, -0.9031559036148179009373393455462064594030, 0.9031559036148179009373393455462064594030, -0.9602081521348300174878431789693422615528, 0.9602081521348300174878431789693422615528, -0.9924068438435843519940249279898125678301, 0.9924068438435843519940249279898125678301],
  [-0.0765265211334973383117130651953630149364, 0.0765265211334973383117130651953630149364, -0.2277858511416450681963397073559463024139, 0.2277858511416450681963397073559463024139, -0.3737060887154195487624974703066982328892, 0.3737060887154195487624974703066982328892, -0.5108670019508271264996324134699534624815, 0.5108670019508271264996324134699534624815, -0.6360536807265150249790508496516849845648, 0.6360536807265150249790508496516849845648, -0.7463319064601507957235071444301865994930, 0.7463319064601507957235071444301865994930, -0.8391169718222187823286617458506952971220, 0.8391169718222187823286617458506952971220, -0.9122344282513259461353527512983419001102, 0.9122344282513259461353527512983419001102, -0.9639719272779138092843709273438435047865, 0.9639719272779138092843709273438435047865, -0.9931285991850948846604296704754233360291, 0.9931285991850948846604296704754233360291],
  [0.0000000000000000000000000000000000000000, -0.1455618541608950933241573011400760151446, 0.1455618541608950933241573011400760151446, -0.2880213168024011172185794293909566476941, 0.2880213168024011172185794293909566476941, -0.4243421202074387776903563462838064879179, 0.4243421202074387776903563462838064879179, -0.5516188358872198271853903861483559012413, 0.5516188358872198271853903861483559012413, -0.6671388041974123384036943207320291548967, 0.6671388041974123384036943207320291548967, -0.7684399634756778896260698275000322610140, 0.7684399634756778896260698275000322610140, -0.8533633645833172964856316866644192487001, 0.8533633645833172964856316866644192487001, -0.9200993341504007938524978271743748337030, 0.9200993341504007938524978271743748337030, -0.9672268385663063128276917268522083759308, 0.9672268385663063128276917268522083759308, -0.9937521706203894522602126926358323544264, 0.9937521706203894522602126926358323544264],
  [-0.0697392733197222253194169638845778536052, 0.0697392733197222253194169638845778536052, -0.2078604266882212725509049278116435743868, 0.2078604266882212725509049278116435743868, -0.3419358208920842412403828802780481055379, 0.3419358208920842412403828802780481055379, -0.4693558379867570073962212973128771409392, 0.4693558379867570073962212973128771409392, -0.5876404035069116016387624767958186566830, 0.5876404035069116016387624767958186566830, -0.6944872631866827461522007070016115903854, 0.6944872631866827461522007070016115903854, -0.7878168059792081123759999172762036323547, 0.7878168059792081123759999172762036323547, -0.8658125777203001804949167308222968131304, 0.8658125777203001804949167308222968131304, -0.9269567721871739829353487039043102413416, 0.9269567721871739829353487039043102413416, -0.9700604978354286922481719557254109531641, 0.9700604978354286922481719557254109531641, -0.9942945854823992402060639506089501082897, 0.9942945854823992402060639506089501082897],
  [0.0000000000000000000000000000000000000000, -0.1332568242984661088801345840693102218211, 0.1332568242984661088801345840693102218211, -0.2641356809703449548543119362875586375594, 0.2641356809703449548543119362875586375594, -0.3903010380302908144400930723350029438734, 0.3903010380302908144400930723350029438734, -0.5095014778460075222099590064317453652620, 0.5095014778460075222099590064317453652620, -0.6196098757636461229481028567533940076828, 0.6196098757636461229481028567533940076828, -0.7186613631319501704908248029823880642653, 0.7186613631319501704908248029823880642653, -0.8048884016188398993207897547108586877584, 0.8048884016188398993207897547108586877584, -0.8767523582704416229560706597112584859133, 0.8767523582704416229560706597112584859133, -0.9329710868260161493736859483760781586170, 0.9329710868260161493736859483760781586170, -0.9725424712181152120393790028174407780170, 0.9725424712181152120393790028174407780170, -0.9947693349975521570627279288601130247116, 0.9947693349975521570627279288601130247116],
  [-0.0640568928626056299791002857091370970011, 0.0640568928626056299791002857091370970011, -0.1911188674736163106704367464772076345980, 0.1911188674736163106704367464772076345980, -0.3150426796961633968408023065421730279922, 0.3150426796961633968408023065421730279922, -0.4337935076260451272567308933503227308393, 0.4337935076260451272567308933503227308393, -0.5454214713888395626995020393223967403173, 0.5454214713888395626995020393223967403173, -0.6480936519369755455244330732966773211956, 0.6480936519369755455244330732966773211956, -0.7401241915785543579175964623573236167431, 0.7401241915785543579175964623573236167431, -0.8200019859739029470802051946520805358887, 0.8200019859739029470802051946520805358887, -0.8864155270044010714869386902137193828821, 0.8864155270044010714869386902137193828821, -0.9382745520027327978951348086411599069834, 0.9382745520027327978951348086411599069834, -0.9747285559713094738043537290650419890881, 0.9747285559713094738043537290650419890881, -0.9951872199970213106468008845695294439793, 0.9951872199970213106468008845695294439793]
]

let FBLegendreGaussWeightValues : [[Double]] = [
  [], [],
  [1.0000000000000000000000000000000000000000,1.0000000000000000000000000000000000000000],
  [0.8888888888888888395456433499930426478386,0.5555555555555555802271783250034786760807,0.5555555555555555802271783250034786760807],
  [0.6521451548625460947761212082696147263050,0.6521451548625460947761212082696147263050,0.3478548451374538497127275604725582525134,0.3478548451374538497127275604725582525134],
  [0.5688888888888888883954564334999304264784,0.4786286704993664709029133064177585765719,0.4786286704993664709029133064177585765719,0.2369268850561890848993584768322762101889,0.2369268850561890848993584768322762101889],
  [0.3607615730481386062677984227775596082211,0.3607615730481386062677984227775596082211,0.4679139345726910370615314604947343468666,0.4679139345726910370615314604947343468666,0.1713244923791703566706701167277060449123,0.1713244923791703566706701167277060449123],
  [0.4179591836734694032529091600736137479544,0.3818300505051189230876218516641529276967,0.3818300505051189230876218516641529276967,0.2797053914892766446342875497066415846348,0.2797053914892766446342875497066415846348,0.1294849661688697028960604029634851031005,0.1294849661688697028960604029634851031005],
  [0.3626837833783619902128236844873754307628,0.3626837833783619902128236844873754307628,0.3137066458778872690693617641954915598035,0.3137066458778872690693617641954915598035,0.2223810344533744820516574236535234376788,0.2223810344533744820516574236535234376788,0.1012285362903762586661571276636095717549,0.1012285362903762586661571276636095717549],
  [0.3302393550012597822629345500899944454432,0.1806481606948573959137149813614087179303,0.1806481606948573959137149813614087179303,0.0812743883615744122650426106702070683241,0.0812743883615744122650426106702070683241,0.3123470770400028628799304897256661206484,0.3123470770400028628799304897256661206484,0.2606106964029354378098446431977208703756,0.2606106964029354378098446431977208703756],
  [0.2955242247147528700246255084493895992637,0.2955242247147528700246255084493895992637,0.2692667193099963496294435572053771466017,0.2692667193099963496294435572053771466017,0.2190863625159820415877476307286997325718,0.2190863625159820415877476307286997325718,0.1494513491505805868886369580650352872908,0.1494513491505805868886369580650352872908,0.0666713443086881379917585377370414789766,0.0666713443086881379917585377370414789766],
  [0.2729250867779006162194832540990319103003,0.2628045445102466515230332788632949814200,0.2628045445102466515230332788632949814200,0.2331937645919904822378043718344997614622,0.2331937645919904822378043718344997614622,0.1862902109277342621584949711177614517510,0.1862902109277342621584949711177614517510,0.1255803694649046120535018644659430719912,0.1255803694649046120535018644659430719912,0.0556685671161736631007421749472996452823,0.0556685671161736631007421749472996452823],
  [0.2491470458134027732288728884668671526015,0.2491470458134027732288728884668671526015,0.2334925365383548057085505433860816992819,0.2334925365383548057085505433860816992819,0.2031674267230659247651658461109036579728,0.2031674267230659247651658461109036579728,0.1600783285433462210800570346691529266536,0.1600783285433462210800570346691529266536,0.1069393259953184266430881166343169752508,0.1069393259953184266430881166343169752508,0.0471753363865118277575838590109924552962,0.0471753363865118277575838590109924552962],
  [0.2325515532308738975153517003491288051009,0.2262831802628972321933531475224299356341,0.2262831802628972321933531475224299356341,0.2078160475368885096170146198346628807485,0.2078160475368885096170146198346628807485,0.1781459807619457380578609217991470359266,0.1781459807619457380578609217991470359266,0.1388735102197872495199959530509659089148,0.1388735102197872495199959530509659089148,0.0921214998377284516317686779984796885401,0.0921214998377284516317686779984796885401,0.0404840047653158771612247335269785253331,0.0404840047653158771612247335269785253331],
  [0.2152638534631577948985636794532183557749,0.2152638534631577948985636794532183557749,0.2051984637212956041896205761076998896897,0.2051984637212956041896205761076998896897,0.1855383974779378219999159682629397138953,0.1855383974779378219999159682629397138953,0.1572031671581935463599677404999965801835,0.1572031671581935463599677404999965801835,0.1215185706879031851679329179205524269491,0.1215185706879031851679329179205524269491,0.0801580871597602079292599341897584963590,0.0801580871597602079292599341897584963590,0.0351194603317518602714208952875196700916,0.0351194603317518602714208952875196700916],
  [0.2025782419255612865072180284187197685242,0.1984314853271115786093048427574103698134,0.1984314853271115786093048427574103698134,0.1861610000155622113293674146916600875556,0.1861610000155622113293674146916600875556,0.1662692058169939202105780395868350751698,0.1662692058169939202105780395868350751698,0.1395706779261543240000520427201990969479,0.1395706779261543240000520427201990969479,0.1071592204671719394948325998484506271780,0.1071592204671719394948325998484506271780,0.0703660474881081243747615872052847407758,0.0703660474881081243747615872052847407758,0.0307532419961172691358353148416426847689,0.0307532419961172691358353148416426847689],
  [0.1894506104550685021692402187909465283155,0.1894506104550685021692402187909465283155,0.1826034150449235837765371570640127174556,0.1826034150449235837765371570640127174556,0.1691565193950025358660127494658809155226,0.1691565193950025358660127494658809155226,0.1495959888165767359691216142891789786518,0.1495959888165767359691216142891789786518,0.1246289712555338768940060845125117339194,0.1246289712555338768940060845125117339194,0.0951585116824927856882254673109855502844,0.0951585116824927856882254673109855502844,0.0622535239386478936318702892549481475726,0.0622535239386478936318702892549481475726,0.0271524594117540964133272751723779947497,0.0271524594117540964133272751723779947497],
  [0.1794464703562065333031227964966092258692,0.1765627053669926449508409405098063871264,0.1765627053669926449508409405098063871264,0.1680041021564500358653759803928551264107,0.1680041021564500358653759803928551264107,0.1540457610768102836296122859494062140584,0.1540457610768102836296122859494062140584,0.1351363684685254751283167706787935458124,0.1351363684685254751283167706787935458124,0.1118838471934039680011352402289048768580,0.1118838471934039680011352402289048768580,0.0850361483171791776580761279547004960477,0.0850361483171791776580761279547004960477,0.0554595293739872027827253475606994470581,0.0554595293739872027827253475606994470581,0.0241483028685479314545681006620725383982,0.0241483028685479314545681006620725383982],
  [0.1691423829631436004383715498988749459386,0.1691423829631436004383715498988749459386,0.1642764837458327298325144738555536605418,0.1642764837458327298325144738555536605418,0.1546846751262652419622867228099494241178,0.1546846751262652419622867228099494241178,0.1406429146706506538855308008351130411029,0.1406429146706506538855308008351130411029,0.1225552067114784593471199514169711619616,0.1225552067114784593471199514169711619616,0.1009420441062871681703327908508072141558,0.1009420441062871681703327908508072141558,0.0764257302548890515847546112127020023763,0.0764257302548890515847546112127020023763,0.0497145488949697969549568199454370187595,0.0497145488949697969549568199454370187595,0.0216160135264833117019200869890482863411,0.0216160135264833117019200869890482863411],
  [0.1610544498487836984068621859478298574686,0.1589688433939543399375793342187535017729,0.1589688433939543399375793342187535017729,0.1527660420658596696075193221986410208046,0.1527660420658596696075193221986410208046,0.1426067021736066031678547005867585539818,0.1426067021736066031678547005867585539818,0.1287539625393362141547726196222356520593,0.1287539625393362141547726196222356520593,0.1115666455473339896409257221421285066754,0.1115666455473339896409257221421285066754,0.0914900216224499990280705219447554554790,0.0914900216224499990280705219447554554790,0.0690445427376412262931992813719261903316,0.0690445427376412262931992813719261903316,0.0448142267656995996194524423117400147021,0.0448142267656995996194524423117400147021,0.0194617882297264781221723950466184760444,0.0194617882297264781221723950466184760444],
  [0.1527533871307258372951309866039082407951,0.1527533871307258372951309866039082407951,0.1491729864726037413369397199858212843537,0.1491729864726037413369397199858212843537,0.1420961093183820411756101975697674788535,0.1420961093183820411756101975697674788535,0.1316886384491766370796739238357986323535,0.1316886384491766370796739238357986323535,0.1181945319615184120110029653005767613649,0.1181945319615184120110029653005767613649,0.1019301198172404415709380032240005675703,0.1019301198172404415709380032240005675703,0.0832767415767047547436874310733401216567,0.0832767415767047547436874310733401216567,0.0626720483341090678353069165495980996639,0.0626720483341090678353069165495980996639,0.0406014298003869386621822457072994438931,0.0406014298003869386621822457072994438931,0.0176140071391521178811867542890468030237,0.0176140071391521178811867542890468030237],
  [0.1460811336496904144777175815761438570917,0.1445244039899700461138110085812513716519,0.1445244039899700461138110085812513716519,0.1398873947910731496691028041823301464319,0.1398873947910731496691028041823301464319,0.1322689386333374683690777828815043903887,0.1322689386333374683690777828815043903887,0.1218314160537285334440227302366110961884,0.1218314160537285334440227302366110961884,0.1087972991671483785625085261017375160009,0.1087972991671483785625085261017375160009,0.0934444234560338621298214434318651910871,0.0934444234560338621298214434318651910871,0.0761001136283793039316591944043466355652,0.0761001136283793039316591944043466355652,0.0571344254268572049326735395879950374365,0.0571344254268572049326735395879950374365,0.0369537897708524937234741969405149575323,0.0369537897708524937234741969405149575323,0.0160172282577743345377552230957007850520,0.0160172282577743345377552230957007850520],
  [0.1392518728556319806966001806358690373600,0.1392518728556319806966001806358690373600,0.1365414983460151721050834794368711300194,0.1365414983460151721050834794368711300194,0.1311735047870623838139891859100316651165,0.1311735047870623838139891859100316651165,0.1232523768105124178928733158500108402222,0.1232523768105124178928733158500108402222,0.1129322960805392156435900119504367467016,0.1129322960805392156435900119504367467016,0.1004141444428809648581335522976587526500,0.1004141444428809648581335522976587526500,0.0859416062170677286236042391465161927044,0.0859416062170677286236042391465161927044,0.0697964684245204886048341563764552120119,0.0697964684245204886048341563764552120119,0.0522933351526832859712534684604179346934,0.0522933351526832859712534684604179346934,0.0337749015848141515006020085820637177676,0.0337749015848141515006020085820637177676,0.0146279952982721998810955454928262042813,0.0146279952982721998810955454928262042813],
  [0.1336545721861061852830943053049850277603,0.1324620394046966131984532921705977059901,0.1324620394046966131984532921705977059901,0.1289057221880821613169132433540653437376,0.1289057221880821613169132433540653437376,0.1230490843067295336776822978208656422794,0.1230490843067295336776822978208656422794,0.1149966402224113642960290349037677515298,0.1149966402224113642960290349037677515298,0.1048920914645414120824895576333801727742,0.1048920914645414120824895576333801727742,0.0929157660600351542612429511791560798883,0.0929157660600351542612429511791560798883,0.0792814117767189491248203125906002242118,0.0792814117767189491248203125906002242118,0.0642324214085258499151720457120973151177,0.0642324214085258499151720457120973151177,0.0480376717310846690356385124687221832573,0.0480376717310846690356385124687221832573,0.0309880058569794447631551292943186126649,0.0309880058569794447631551292943186126649,0.0134118594871417712993677540112003043760,0.0134118594871417712993677540112003043760],
  [0.1279381953467521593204025975865079089999,0.1279381953467521593204025975865079089999,0.1258374563468283025002847352880053222179,0.1258374563468283025002847352880053222179,0.1216704729278033914052770114722079597414,0.1216704729278033914052770114722079597414,0.1155056680537255991980671865348995197564,0.1155056680537255991980671865348995197564,0.1074442701159656343712356374453520402312,0.1074442701159656343712356374453520402312,0.0976186521041138843823858906034729443491,0.0976186521041138843823858906034729443491,0.0861901615319532743431096832864568568766,0.0861901615319532743431096832864568568766,0.0733464814110802998392557583429152145982,0.0733464814110802998392557583429152145982,0.0592985849154367833380163688161701429635,0.0592985849154367833380163688161701429635,0.0442774388174198077483545432642131345347,0.0442774388174198077483545432642131345347,0.0285313886289336633705904233693217975087,0.0285313886289336633705904233693217975087,0.0123412297999872001830201639904771582223,0.0123412297999872001830201639904771582223]
]

func FBGaussQuadratureBaseForCubic(_ t: Double, p1: Double, p2: Double, p3: Double, p4: Double) -> Double
{
  let t1 = (-3.0 * p1) + (9.0 * p2) - (9.0 * p3) + (3.0 * p4)
  let t2 = t * t1 + 6.0 * p1 - 12.0 * p2 + 6.0 * p3

  return t * t2 - 3.0 * p1 + 3.0 * p2
  //return t * (t * (-3 * p1 + 9 * p2 - 9 * p3 + 3 * p4) + 6 * p1 + 12 * p2 + 3 * p3) - 3 * p1 + 3 * p2
}

func FBGaussQuadratureFOfTForCubic(_ t: Double, p1: CGPoint, p2: CGPoint, p3: CGPoint, p4: CGPoint) -> Double
{
  let baseX = FBGaussQuadratureBaseForCubic(t,
    p1: Double(p1.x),
    p2: Double(p2.x),
    p3: Double(p3.x),
    p4: Double(p4.x))
  let baseY = FBGaussQuadratureBaseForCubic(t,
    p1: Double(p1.y),
    p2: Double(p2.y),
    p3: Double(p3.y),
    p4: Double(p4.y))

  return sqrt(baseX * baseX + baseY * baseY)
}

func FBGaussQuadratureComputeCurveLengthForCubic(_ z: Double, steps: Int, p1: CGPoint, p2: CGPoint, p3: CGPoint, p4: CGPoint) -> Double
{
  let z2 = Double(z / 2.0)
  var sum : Double = 0.0
  for i in 0 ..< steps {
    let correctedT: Double = z2 * FBLegendreGaussAbscissaeValues[steps][i] + z2
    sum += FBLegendreGaussWeightValues[steps][i] * FBGaussQuadratureFOfTForCubic(correctedT, p1: p1, p2: p2, p3: p3, p4: p4)
  }
  return z2 * sum
}

func FBSign(_ value: CGFloat) -> Int
{
  if value < 0.0 {
    return -1
  } else {
    return 1
  }
}

func FBCountBezierCrossings(_ bezierPoints: [CGPoint], degree: Int) -> Int {

  var count : Int = 0
  var sign = FBSign(bezierPoints[0].y)

  var previousSign = sign
  for i in 1 ... degree {
    sign = FBSign(bezierPoints[i].y)
    if sign != previousSign {
      count += 1
    }
    previousSign = sign;
  }
  return count
}

let FBFindBezierRootsMaximumDepth = 64

// 297
//static BOOL FBIsControlPolygonFlatEnough(NSPoint *bezierPoints, NSUInteger degree, NSPoint *intersectionPoint)
// FBIsControlPolygonFlatEnough Usage:
// var intersectAt = CGPoint(x:0,y:0)
// var boolGotit = FBIsControlPolygonFlatEnough(points,degree,&intersectAt)
func FBIsControlPolygonFlatEnough(_ bezierPoints: [CGPoint], degree: Int, intersectionPoint: inout CGPoint) -> Bool {

  // 2^-63
  let FBFindBezierRootsErrorThreshold = CGFloat(ldexpf(Float(1.0), Int32(-1 * (FBFindBezierRootsMaximumDepth - 1))))

  let line = FBNormalizedLine(point1: bezierPoints[0], point2: bezierPoints[degree])

  // Find the bounds around the line
  var belowDistance = 0.0
  var aboveDistance = 0.0
  for i in 1 ..< degree {
    let distance = line.distanceFromPoint(bezierPoints[i])
    if distance > aboveDistance {
      aboveDistance = distance
    }

    if distance < belowDistance {
      belowDistance = distance
    }
  }

  let zeroLine = FBNormalizedLine(a: 0.0, b: 1.0, c: 0.0)
  let aboveLine = line.copyWithOffset(-aboveDistance)
  let intersect1 = zeroLine.intersectionWith(aboveLine)

  let belowLine = line.copyWithOffset(-belowDistance)
  let intersect2 = zeroLine.intersectionWith(belowLine)

  let error = max(intersect1.x, intersect2.x) - min(intersect1.x, intersect2.x)
  if error < FBFindBezierRootsErrorThreshold {
    intersectionPoint = zeroLine.intersectionWith(line)
    return true
  }

  return false
}

// 330
func FBFindBezierRootsWithDepth(_ bezierPoints: [CGPoint], degree: Int, depth: Int, perform: (_ root: Double) -> Void) {

  let crossingCount = FBCountBezierCrossings(bezierPoints, degree: degree)
  if crossingCount == 0 {
    return
  }
  else if crossingCount == 1 {
    if depth >= FBFindBezierRootsMaximumDepth {
      let root = Double(bezierPoints[0].x + bezierPoints[degree].x) / 2.0
      perform(root)
      return
    }
    var intersectionPoint = CGPoint.zero
    if FBIsControlPolygonFlatEnough(bezierPoints, degree: degree, intersectionPoint: &intersectionPoint) {
      perform(Double(intersectionPoint.x))
      return
    }
  }

  // Subdivide and try again
  let bwp = BezierWithPoints(degree, bezierPoints: bezierPoints, parameter: 0.5, withCurves: true)
  FBFindBezierRootsWithDepth(bwp.leftCurve!, degree: degree, depth: depth + 1, perform: perform)
  FBFindBezierRootsWithDepth(bwp.rightCurve!, degree: degree, depth: depth + 1, perform: perform)
}

// 356
func FBFindBezierRoots(_ bezierPoints: [CGPoint], degree: Int, perform: (_ root: Double) -> Void) {

  FBFindBezierRootsWithDepth(bezierPoints, degree: degree, depth: 0, perform: perform)
}


// ========================================================
// MARK: ---- Convex Hull ----
// ========================================================

// 366
func FBConvexHullDoPointsTurnWrongDirection(_ point1: CGPoint, point2: CGPoint, point3: CGPoint) -> Bool {

  let area = CounterClockwiseTurn(point1, point2: point2, point3: point3)
  return FBAreValuesClose(area, value2: 0.0) || area < 0.0
}

// 372
func FBConvexHullBuildFromPoints(_ inPoints: [CGPoint]) -> (hull: [CGPoint], hullLength: Int) {

  // Compute the convex hull for this bezier curve. The convex hull is made up of the end and control points.
  //  The hard part is determine the order they go in, and if any are inside or colinear with the convex hull.

  // Uses the Monotone chain algorithm:
  //  http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain

  // Start with all the end and control points in any order.
  let numberOfPoints = 4

  var points = inPoints

  // Sort points ascending x, if equal compare y
  //  Bubble sort, which should be ok with a max of 4 elements, and the fact that our one current use case
  //  already has them in ascending X order (i.e. should be just comparisons to verify)
  var sortLength = numberOfPoints
  repeat {
    var newSortLength = 0
    for i in 1 ..< sortLength {
      if ( points[i - 1].x > points[i].x || (FBAreValuesClose(points[i - 1].x, value2: points[i].x) && points[i - 1].y > points[i].y) ) {
        let tempPoint = points[i]
        points[i] = points[i - 1]
        points[i - 1] = tempPoint
        newSortLength = i
      }
    }
    sortLength = newSortLength
  } while sortLength > 0

  // Create the results
  var filledInIx = 0
  var results = [CGPoint](repeating: CGPoint.zero, count: 8)

  // Build lower hull
  for i in 0 ..< numberOfPoints {
    while filledInIx >= 2 && FBConvexHullDoPointsTurnWrongDirection(results[filledInIx - 2], point2: results[filledInIx - 1], point3: points[i]) {
      filledInIx -= 1
    }
    results[filledInIx] = points[i];
    filledInIx += 1;
  }

  // Build upper hull
  let thresholdIndex = filledInIx + 1
  for i in (0 ... numberOfPoints - 2).reversed() {
    while filledInIx >= thresholdIndex && FBConvexHullDoPointsTurnWrongDirection(results[filledInIx - 2], point2: results[filledInIx - 1], point3: points[i]) {
      filledInIx -= 1
    }

    results[filledInIx] = points[i];
    filledInIx += 1;
  }

  return (hull: results, hullLength: filledInIx - 1)
}

func ILLUSTRATE_CALL_TO_FBConvexHullBuildFromPoints() {

  // In C this was:
  //  NSUInteger convexHullLength = 0;
  //  NSPoint convexHull[8] = {};
  //  FBConvexHullBuildFromPoints(distanceBezierPoints, convexHull, &convexHullLength);

  let distanceBezierPoints = [CGPoint](repeating: CGPoint.zero, count: 4)

  let (_, convexHullLength) = FBConvexHullBuildFromPoints(distanceBezierPoints)

  if convexHullLength < 0 {
    print("YIKES")
  }
}



// ========================================================
// MARK: ---- FBBezierCurveData ----
// ========================================================


struct FBBezierCurveLocation {
  var parameter : Double
  var distance : Double

  init(parameter: Double, distance: Double) {
    self.parameter = parameter
    self.distance = distance
  }
}

class FBBezierCurveData {
  var endPoint1 : CGPoint
  var controlPoint1 : CGPoint
  var controlPoint2 : CGPoint
  var endPoint2 : CGPoint

  var isStraightLine : Bool		// GPC: flag when curve came from a straight line segment

  var length : Double?         // cached value
  fileprivate var _bounds : CGRect? // cached value
  var _isPoint : Bool?          // cached value
  var _boundingRect : CGRect?   // cached value


  // FBBezierCurveDataMake
  // let some_data = FBBezierCurveData(endPoint1, controlPoint1, controlPoint2, endPoint2, isStraightLine)
  //
  init(endPoint1 : CGPoint, controlPoint1 : CGPoint, controlPoint2 : CGPoint, endPoint2 : CGPoint, isStraightLine: Bool) {
    self.endPoint1 = endPoint1
    self.controlPoint1 = controlPoint1
    self.controlPoint2 = controlPoint2
    self.endPoint2 = endPoint2
    self.isStraightLine = isStraightLine

    self.length = FBBezierCurveDataInvalidLength
  }

  init(cloning clone : FBBezierCurveData) {
    self.endPoint1 = clone.endPoint1
    self.controlPoint1 = clone.controlPoint1
    self.controlPoint2 = clone.controlPoint2
    self.endPoint2 = clone.endPoint2
    self.isStraightLine = clone.isStraightLine

    self.length = clone.length
  }


  // ============================  NOTE  ===================================
  /*  static const BOOL FBBezierCurveDataInvalidIsPoint = -1;

  NOTE:  --- FBBezierCurveDataInvalidIsPoint ---

  Instead of using the C language trick of setting a BOOL to a negative number
  to see whether a test has ever been performed, we are using a Swift optional

  if _data.isPoint != nil, let isPoint = _data.isPoint {
  if isPoint {
  println("Got it true")
  } else {
  println("Got it false")
  }
  } else {
  println("Have to make sure we set it NOW")
  }
  */
  // ============================--------===================================

  // static BOOL FBBezierCurveDataIsPoint(FBBezierCurveData *me)
  func isPoint() -> Bool
  {
    // If the two end points are close together, then we're a point.
    // Ignore the control points.

    // MARK: This value greatly affects 32-bit calculations
    // LRT - fiddle with this
    let FBClosenessThreshold = isRunningOn64BitDevice ? 1e-5 : 1e-1

    // check cached value
    if _isPoint != nil {
      return _isPoint!
    }

    _isPoint = FBArePointsCloseWithOptions(endPoint1, point2: endPoint2, threshold: FBClosenessThreshold) && FBArePointsCloseWithOptions(endPoint1, point2: controlPoint1, threshold: FBClosenessThreshold) && FBArePointsCloseWithOptions(endPoint1, point2: controlPoint2, threshold: FBClosenessThreshold)

    return _isPoint!;
  }

  // static NSRect FBBezierCurveDataBoundingRect(FBBezierCurveData *me)
  // Becomes:
  // let bnds = curve_data.boundingRect()
  //
  // TODO: change this to: var boundingRect : CGRect
  //func boundingRect() -> CGRect
  var boundingRect : CGRect
  {
    // Use the cache if we have one
    if _boundingRect != nil {
      return _boundingRect!
    }

    let left = min(endPoint1.x, min(controlPoint1.x, min(controlPoint2.x, endPoint2.x)))
    let top = min(endPoint1.y, min(controlPoint1.y, min(controlPoint2.y, endPoint2.y)))
    let right = max(endPoint1.x, max(controlPoint1.x, max(controlPoint2.x, endPoint2.x)))
    let bottom = max(endPoint1.y, max(controlPoint1.y, max(controlPoint2.y, endPoint2.y)))

    _boundingRect = CGRect(x: left, y: top, width: right - left, height: bottom - top)

    return _boundingRect!
  }

  // static NSRect FBBezierCurveDataBounds(FBBezierCurveData* me)
  // Becomes:
  // let bnds = curve_data.bounds()
  //
  // TODO: change this to: var bounds : CGRect
  //func bounds() -> CGRect
  var bounds : CGRect
  {
    // Use the cache if we have one
    if _bounds != nil {
      return _bounds!
    }

    var bounds = CGRect.zero

    if isStraightLine {
      var topLeft = endPoint1
      var bottomRight = topLeft
      FBExpandBoundsByPoint(&topLeft, bottomRight: &bottomRight, point: endPoint2)

      bounds = CGRect(x: topLeft.x, y: topLeft.y, width: bottomRight.x - topLeft.x, height: bottomRight.y - topLeft.y)
    } else {
      // Start with the end points
      var (topLeft, _, _) = pointAtParameter(0)
      var bottomRight = topLeft
      let (lastPoint, _, _) = pointAtParameter(1)

      FBExpandBoundsByPoint(&topLeft, bottomRight: &bottomRight, point: lastPoint);

      // Find the roots, which should be the extremities
      let xRoots : [Double] = FBComputeCubicFirstDerivativeRoots(Double(endPoint1.x), b: Double(controlPoint1.x), c: Double(controlPoint2.x), d: Double(endPoint2.x))

      for i in 0 ..< xRoots.count {
        let t = xRoots[i]
        if t < 0 || t > 1 {
          continue
        }
        let (location, _, _) = pointAtParameter(t)
        FBExpandBoundsByPoint(&topLeft, bottomRight: &bottomRight, point: location)
      }

      let yRoots : [Double] = FBComputeCubicFirstDerivativeRoots(Double(endPoint1.y), b: Double(controlPoint1.y), c: Double(controlPoint2.y), d: Double(endPoint2.y))
      for i in 0 ..< yRoots.count {
        let t = yRoots[i]
        if t < 0 || t > 1 {
          continue
        }
        let (location, _, _) = pointAtParameter(t)
        FBExpandBoundsByPoint(&topLeft, bottomRight: &bottomRight, point: location)
      }

      bounds = CGRect(x: topLeft.x, y: topLeft.y, width: bottomRight.x - topLeft.x, height: bottomRight.y - topLeft.y)
    }
    
    // Cache the value
    _bounds = bounds
    
    return bounds
  }


  // static CGFloat FBBezierCurveDataGetLengthAtParameter(FBBezierCurveData* me, CGFloat parameter)
  // Becomes:
  // let someLength = curve_data.getLengthAtParameter(CGFloat parameter)
  //
  func getLengthAtParameter(_ parameter: Double) -> Double {

    // Use the cached value if at all possible
    if parameter == 1.0 && length != nil && length != FBBezierCurveDataInvalidLength {
      return length!
    }

    // If it's a line, use that equation instead
    var calculatedLength = FBBezierCurveDataInvalidLength;
    if isStraightLine {
      calculatedLength = FBDistanceBetweenPoints(endPoint1, point2: endPoint2) * parameter
    } else {
      calculatedLength = FBGaussQuadratureComputeCurveLengthForCubic(Double(parameter), steps: 12, p1: endPoint1, p2: controlPoint1, p3: controlPoint2, p4: endPoint2)
    }

    // If possible, update our cache
    if parameter == 1.0 {
      length = calculatedLength
    }

    return calculatedLength
  }

  func reversed() -> FBBezierCurveData
  {
    return FBBezierCurveData(endPoint1: endPoint2, controlPoint1: controlPoint2, controlPoint2: controlPoint1, endPoint2: endPoint1, isStraightLine: isStraightLine)
  }

  // static CGFloat FBBezierCurveDataGetLength(FBBezierCurveData* me)
  // Becomes:
  // let someLength = curve_data.getLength()
  //
  func getLength() -> Double {
    return getLengthAtParameter(1.0)
  }


  // NSPoint FBBezierCurveDataPointAtParameter(FBBezierCurveData me, CGFloat param, FBB-C-Data *leftBezCurve, FBB-C-Data *rightBezCurve)
  // Becomes:
  // let (point,left,right) = curve_data.pointAtParameter(param_float)
  //
  func pointAtParameter(_ parameter: Double) -> (point: CGPoint, leftCurve: FBBezierCurveData?, rightCurve: FBBezierCurveData?) {

    // This method is a simple wrapper around the BezierWithPoints() helper function. It computes the 2D point at the given parameter,
    //  and (optionally) the resulting curves that splitting at the parameter would create.

    let points = [endPoint1, controlPoint1, controlPoint2, endPoint2]

    let bwp = BezierWithPoints(3, bezierPoints: points, parameter: parameter, withCurves: true);

    var leftBCData : FBBezierCurveData? = nil
    if let leftA = bwp.leftCurve {
      leftBCData = FBBezierCurveData(endPoint1: leftA[0], controlPoint1: leftA[1], controlPoint2: leftA[2], endPoint2: leftA[3], isStraightLine: isStraightLine)
    }

    var rightBCData : FBBezierCurveData? = nil
    if let rightA = bwp.rightCurve {
      rightBCData = FBBezierCurveData(endPoint1: rightA[0], controlPoint1: rightA[1], controlPoint2: rightA[2], endPoint2: rightA[3], isStraightLine: isStraightLine)
    }


    return (point: bwp.point, leftCurve: leftBCData, rightCurve: rightBCData)
  }

  // 492
  // static FBBezierCurveData FBBezierCurveDataSubcurveWithRange(FBBezierCurveData me, FBRange range)
  // Becomes:
  // let new_curve_data = curve_data.subcurveWithRange(range)
  //
  func subcurveWithRange(_ range: FBRange) -> FBBezierCurveData
  {
    // Return a bezier curve representing the parameter range specified. We do this by splitting
    //  twice: once on the minimum, the splitting the result of that on the maximum.

    let upperCurve = self.pointAtParameter(range.minimum).rightCurve!

    if range.minimum == 1.0 {
      return upperCurve           // avoid the divide by zero below
    }

    // We need to adjust the maximum parameter to fit on the new curve before we split again
    let adjustedMaximum = (range.maximum - range.minimum) / (1.0 - range.minimum)

    let lowerCurve = upperCurve.pointAtParameter(adjustedMaximum).leftCurve!

    return lowerCurve
  }

  // 508
  // static FBNormalizedLine FBBezierCurveDataRegularFatLineBounds(FBBezierCurveData me, FBRange *range)
  // Becomes:
  // let normalized_line = curve_data.regularFatLineBounds(&range)
  //
  func regularFatLineBounds() -> (line: FBNormalizedLine, range: FBRange)
  {
    // Create the fat line based on the end points
    let line = FBNormalizedLine(point1: endPoint1, point2: endPoint2)

    // Compute the bounds of the fat line. The fat line bounds should entirely encompass the
    //  bezier curve. Since we know the convex hull entirely compasses the curve, just take
    //  all four points that define this cubic bezier curve. Compute the signed distances of
    //  each of the end and control points from the fat line, and that will give us the bounds.

    // In this case we know that the end points are on the line, thus their distances will be 0.
    //  So we can skip computing those and just use 0.
    let controlPoint1Distance = line.distanceFromPoint(controlPoint1)
    let controlPoint2Distance = line.distanceFromPoint(controlPoint2)

    let minim = min(controlPoint1Distance, min(controlPoint2Distance, 0.0))
    let maxim = max(controlPoint1Distance, max(controlPoint2Distance, 0.0))

    return (line, FBRange(minimum: minim, maximum: maxim))
  }

  // 530
  // static FBNormalizedLine FBBezierCurveDataPerpendicularFatLineBounds(FBBezierCurveData me, FBRange *range)
  // Becomes:
  // let normalized_line = curve_data.perpendicularFatLineBounds(&range)
  //
  func perpendicularFatLineBounds() -> (line: FBNormalizedLine, range: FBRange)
  {
    // Create a fat line that's perpendicular to the line created by the two end points.
    let normal = FBLineNormal(endPoint1, lineEnd: endPoint2)
    let startPoint = FBLineMidpoint(endPoint1, lineEnd: endPoint2)
    let endPoint = FBAddPoint(startPoint, point2: normal)
    let line = FBNormalizedLine(point1: startPoint, point2: endPoint)

    // Compute the bounds of the fat line. The fat line bounds should entirely encompass the
    //  bezier curve. Since we know the convex hull entirely compasses the curve, just take
    //  all four points that define this cubic bezier curve. Compute the signed distances of
    //  each of the end and control points from the fat line, and that will give us the bounds.
    let controlPoint1Distance = line.distanceFromPoint(controlPoint1)
    let controlPoint2Distance = line.distanceFromPoint(controlPoint2)
    let point1Distance = line.distanceFromPoint(endPoint1)
    let point2Distance = line.distanceFromPoint(endPoint2)

    let minim = min(controlPoint1Distance, min(controlPoint2Distance, min(point1Distance, point2Distance)))
    let maxim = max(controlPoint1Distance, max(controlPoint2Distance, max(point1Distance, point2Distance)))

    return (line, FBRange(minimum: minim, maximum: maxim))
  }

  // 555
  // static FBRange FBBezierCurveDataClipWithFatLine(FBBezierCurveData me, FBNormalizedLine fatLine, FBRange bounds)
  // Becomes:
  // let new_range = curve_data.clipWithFatLine(fatline, bounds)
  //
  func clipWithFatLine(_ fatLine: FBNormalizedLine, bounds: FBRange) -> FBRange
  {
    // This method computes the range of self that could possibly intersect with
    // the fat line passed in (and thus with the curve enclosed by the fat line).
    //
    // To do that, we first compute the signed distance of all our points (end and control)
    // from the fat line, and map those onto a bezier curve at evenly spaced intervals
    // from [0..1]. The parts of the distance bezier that fall inside of the fat line bounds
    // correspond to the parts of ourself that could potentially intersect with the other curve.
    // Ideally, we'd calculate where the distance bezier intersected the horizontal lines
    // representing the fat line bounds. However, computing those intersections is hard and
    // costly. So instead we'll compute the convex hull, and intersect those lines with the
    // fat line bounds. The intersection with the lowest x coordinate will be the minimum,
    // and the intersection with the highest x coordinate will be the maximum.

    // The convex hull (for cubic beziers) is the four points that define the curve.
    // A useful property of the convex hull is that the entire curve lies inside of it.

    // First calculate bezier curve points distance from the fat line that's clipping us
    let distanceBezierPoints : [CGPoint] = [
      CGPoint(
        x: 0.0,
        y: fatLine.distanceFromPoint(endPoint1)),
      CGPoint(
        x: 1.0/3.0,
        y: fatLine.distanceFromPoint(controlPoint1)),
      CGPoint(
        x: 2.0/3.0,
        y: fatLine.distanceFromPoint(controlPoint2)),
      CGPoint(
        x: 1.0,
        y: fatLine.distanceFromPoint(endPoint2))
    ]

    let (convexHull, convexHullLength) = FBConvexHullBuildFromPoints(distanceBezierPoints)

    // Find intersections of convex hull with the fat line bounds
    var range = FBRange(minimum: 1.0, maximum: 0.0)

    for i in 0 ..< convexHullLength {
      // Pull out the current line on the convex hull
      let indexOfNext = i < (convexHullLength - 1) ? i + 1 : 0

      let startPoint = convexHull[i]
      let endPoint = convexHull[indexOfNext]
      var intersectionPoint = CGPoint.zero

      // See if the segment of the convex hull intersects with the minimum fat line bounds
      if LineIntersectsHorizontalLine(startPoint, endPoint: endPoint, y: bounds.minimum, intersectPoint: &intersectionPoint) {
        if Double(intersectionPoint.x) < range.minimum {
          range.minimum = Double(intersectionPoint.x)
        }
        if Double(intersectionPoint.x) > range.maximum {
          range.maximum = Double(intersectionPoint.x)
        }
      }

      // See if this segment of the convex hull intersects with the maximum fat line bounds
      if LineIntersectsHorizontalLine(startPoint, endPoint: endPoint, y: bounds.maximum, intersectPoint: &intersectionPoint) {
        if Double(intersectionPoint.x) < range.minimum {
          range.minimum = Double(intersectionPoint.x)
        }
        if Double(intersectionPoint.x) > range.maximum {
          range.maximum = Double(intersectionPoint.x)
        }
      }

      // We want to be able to refine t even if the convex hull lies completely inside the bounds.
      // This also allows us to be able to use range of [1..0] as a sentinel value meaning the
      // convex hull lies entirely outside of bounds, and the curves don't intersect.
      if Double(startPoint.y) < bounds.maximum && Double(startPoint.y) > bounds.minimum {
        if Double(startPoint.x) < range.minimum {
          range.minimum = Double(startPoint.x)
        }
        if Double(startPoint.x) > range.maximum {
          range.maximum = Double(startPoint.x)
        }
      }
    }

    // Check for bad values
    if range.minimum.isInfinite || range.minimum.isNaN || range.maximum.isInfinite || range.maximum.isNaN {
      range = FBRange(minimum: 0, maximum: 1); // equivalent to: something went wrong, so I don't know
    }
    
    return range
  }

  // 819
  //static void FBBezierCurveDataConvertSelfAndPoint(FBBezierCurveData me, NSPoint point, NSPoint *bezierPoints)
  func convertSelfAndPoint(_ point: CGPoint) -> [CGPoint]
  {
    var selfPoints: [CGPoint] = [endPoint1, controlPoint1, controlPoint2, endPoint2]

    // c[i] in the paper
    let distanceFromPoint = [
      FBSubtractPoint(selfPoints[0], point2: point),
      FBSubtractPoint(selfPoints[1], point2: point),
      FBSubtractPoint(selfPoints[2], point2: point),
      FBSubtractPoint(selfPoints[3], point2: point)
    ]

    // d[i] in the paper
    let weightedDelta = [
      FBScalePoint(FBSubtractPoint(selfPoints[1], point2: selfPoints[0]), scale: 3),
      FBScalePoint(FBSubtractPoint(selfPoints[2], point2: selfPoints[1]), scale: 3),
      FBScalePoint(FBSubtractPoint(selfPoints[3], point2: selfPoints[2]), scale: 3)
    ]

    // Precompute the dot product of distanceFromPoint and weightedDelta in order to speed things up
    var precomputedTable: [[Double]] = [
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ]
    for row in 0 ..< 3 {
      for column in 0 ..< 4 {
        precomputedTable[row][column] = FBDotMultiplyPoint(weightedDelta[row], point2: distanceFromPoint[column])
      }
    }

    // Precompute some of the values to speed things up
    let FBZ: [[Double]] = [
      [1.0, 0.6, 0.3, 0.1],
      [0.4, 0.6, 0.6, 0.4],
      [0.1, 0.3, 0.6, 1.0]
    ]

    // create our output array
    var bezierPoints = [CGPoint](repeating: CGPoint.zero, count: 6)

    // Set the x values of the bezier points
    for i in 0 ..< 6 {
      bezierPoints[i] = CGPoint(x: CGFloat(i) / 5.0, y: 0)
    }

    // Finally set the y values of the bezier points
    let n = 3
    let m = n - 1
    for k in 0 ... (n + m) {
      let lowerBound = max(0, k - m)
      let upperBound = min(k, n)
      for i in lowerBound ... upperBound {
        let j = k - i
        bezierPoints[i + j].y += CGFloat(precomputedTable[j][i] * FBZ[j][i])
      }
    }
    
    return bezierPoints
  }

  // 864
  //static FBBezierCurveLocation FBBezierCurveDataClosestLocationToPoint(FBBezierCurveData me, NSPoint point)
  func closestLocationToPoint(_ point: CGPoint) -> FBBezierCurveLocation
  {
    let bezierPoints = convertSelfAndPoint(point)

    var distance = FBDistanceBetweenPoints(endPoint1, point2: point)
    var parameter = 0.0

    FBFindBezierRoots(bezierPoints, degree: 5) { (root) -> Void in

      let location = self.pointAtParameter(root).point
      let theDistance = FBDistanceBetweenPoints(location, point2: point)
      if ( theDistance < distance ) {
        distance = theDistance
        parameter = root
      }
    }

    let lastDistance = FBDistanceBetweenPoints(endPoint2, point2: point)
    if ( lastDistance < distance ) {
      distance = lastDistance;
      parameter = 1.0;
    }

    let location = FBBezierCurveLocation(parameter: parameter, distance: distance)
    
    return location
  }

  // 893
  //static BOOL FBBezierCurveDataIsEqualWithOptions(FBBezierCurveData me, FBBezierCurveData other, CGFloat threshold)
  func isEqualWithOptions(_ other: FBBezierCurveData, threshold: Double) -> Bool
  {
    if isPoint() || other.isPoint() {
      return false
    }

    if isStraightLine != other.isStraightLine {
      return false
    }

    if isStraightLine {
      return FBArePointsCloseWithOptions(endPoint1, point2: other.endPoint1, threshold: threshold) && FBArePointsCloseWithOptions(endPoint2, point2: other.endPoint2, threshold: threshold)
    }

    return FBArePointsCloseWithOptions(endPoint1, point2: other.endPoint1, threshold: threshold) && FBArePointsCloseWithOptions(controlPoint1, point2: other.controlPoint1, threshold: threshold) && FBArePointsCloseWithOptions(controlPoint2, point2: other.controlPoint2, threshold: threshold) && FBArePointsCloseWithOptions(endPoint2, point2: other.endPoint2, threshold: threshold)
  }

}


// ==================================================
// MARK: Private FBBezierCurveData functions
// ==================================================


// 623
// static FBBezierCurveData FBBezierCurveDataBezierClipWithBezierCurve(FBBezierCurveData me, FBBezierCurveData curve, FBBezierCurveData originalCurve, FBRange *originalRange, BOOL *intersects)
// Becomes:
// let (new_curve, success) = curve_data.bezierClipWithBezierCurve(curve, &originalCurve, &originalRange)
//
func bezierClipWithBezierCurve(_ me: FBBezierCurveData, curve: FBBezierCurveData, originalCurve: inout FBBezierCurveData, originalRange: inout FBRange) -> (clipped: FBBezierCurveData, intersects: Bool)
{
  // This method does the clipping of self. It removes the parts of self that we can determine don't intersect
  //  with curve. It'll return the clipped version of self, update originalRange which corresponds to the range
  //  on the original curve that the return value represents. Finally, it'll set the intersects out parameter
  //  to yes or no depending on if the curves intersect or not.

  // Clipping works as follows:
  //  Draw a line through the two endpoints of the other curve, which we'll call the fat line. Measure the
  //  signed distance between the control points on the other curve and the fat line. The distance from the line
  //  will give us the fat line bounds. Any part of our curve that lies further away from the fat line than the
  //  fat line bounds we know can't intersect with the other curve, and thus can be removed.

  // We actually use two different fat lines. The first one uses the end points of the other curve, and the second
  //  one is perpendicular to the first. Most of the time, the first fat line will clip off more, but sometimes the
  //  second proves to be a better fat line in that it clips off more. We use both in order to converge more quickly.

  // Compute the regular fat line using the end points, then compute the range that could still possibly intersect
  //  with the other curve
  let (fatLine, fatLineBounds) = curve.regularFatLineBounds()
  let regularClippedRange = me.clipWithFatLine(fatLine, bounds: fatLineBounds)

  // A range of [1, 0] is a special sentinel value meaning "they don't intersect".
  // If they don't, bail early to save time
  if regularClippedRange.minimum == 1.0 && regularClippedRange.maximum == 0.0 {
    return (clipped: me, intersects: false)
  }

  // Just in case the regular fat line isn't good enough, try the perpendicular one
  let (perpendicularLine, perpendicularLineBounds) = curve.perpendicularFatLineBounds()
  let perpendicularClippedRange = me.clipWithFatLine(perpendicularLine, bounds: perpendicularLineBounds)

  if perpendicularClippedRange.minimum == 1.0 && perpendicularClippedRange.maximum == 0.0 {
    return (clipped: me, intersects: false)
  }

  // Combine to form Voltron.
  // Take the intersection of the regular fat line range and the perpendicular one.
  let clippedRange = FBRange(
    minimum: max(regularClippedRange.minimum, perpendicularClippedRange.minimum),
    maximum: min(regularClippedRange.maximum, perpendicularClippedRange.maximum))

  // Right now the clipped range is relative to ourself, not the original curve.
  // So map the newly clipped range onto the original range
  let newRange = FBRange(
    minimum: FBRangeScaleNormalizedValue(originalRange, value: clippedRange.minimum),
    maximum: FBRangeScaleNormalizedValue(originalRange, value: clippedRange.maximum))

  originalRange.minimum = newRange.minimum
  originalRange.maximum = newRange.maximum

  // Actually divide the curve, but be sure to use the original curve. This helps with errors building up.
  return (clipped: originalCurve.subcurveWithRange(originalRange), intersects: true)
}


// static BOOL FBBezierCurveDataIsPoint(FBBezierCurveData *me)
// Becomes:
// if curve_data.isPoint()
// SEE NEW ACCESSOR ABOVE: func isPoint() -> Bool


// static NSRect FBBezierCurveDataBoundingRect(FBBezierCurveData *me)
// Becomes:
// let bnds = curve_data.boundingRect()
// SEE NEW ACCESSOR ABOVE: func boundingRect() -> CGRect


// static NSRect FBBezierCurveDataBounds(FBBezierCurveData* me)
// Becomes:
// let bnds = curve_data.bounds()
// SEE NEW ACCESSOR ABOVE: func bounds() -> CGRect


// 759
//static void FBBezierCurveDataRefineIntersectionsOverIterations(NSUInteger iterations, FBRange *usRange, FBRange *themRange, FBBezierCurveData originalUs, FBBezierCurveData originalThem, FBBezierCurveData us, FBBezierCurveData them, FBBezierCurveData nonpointUs, FBBezierCurveData nonpointThem)
// Becomes:
// refineIntersectionsOverIterations(blah, blah, blah.....)
// ========================================================
// NOTE: Need to decide whether this needs to be static
// ========================================================
private func refineIntersectionsOverIterations(_ iterations: Int,
  usRange: inout FBRange,
  themRange: inout FBRange,
  originalUs: inout FBBezierCurveData,
  originalThem: inout FBBezierCurveData,
  us: inout FBBezierCurveData,
  them: inout FBBezierCurveData,
  nonpointUs: inout FBBezierCurveData,
  nonpointThem: inout FBBezierCurveData)
{
  for _ in 0..<iterations {
    var intersects = false

    (us, intersects) = bezierClipWithBezierCurve(us, curve: them, originalCurve: &originalUs, originalRange: &usRange)
    if !intersects {
      (us, intersects) = bezierClipWithBezierCurve(nonpointUs, curve: nonpointThem, originalCurve: &originalUs, originalRange: &usRange)
    }

    (them, intersects) = bezierClipWithBezierCurve(them, curve: us, originalCurve: &originalThem, originalRange: &themRange)
    if !intersects {
      (them, intersects) = bezierClipWithBezierCurve(nonpointThem, curve: nonpointUs, originalCurve: &originalThem, originalRange: &themRange)
    }
    if !them.isPoint() {
      nonpointThem = them
    }
    if !us.isPoint() {
      nonpointUs = us
    }
  }
}


// 777
// static FBBezierCurveData FBBezierCurveDataClipLineOriginalCurve(FBBezierCurveData me, FBBezierCurveData originalCurve, FBBezierCurveData curve, FBRange *originalRange, FBBezierCurveData otherCurve, BOOL *intersects)
// Becomes:
// let (clippedCurve, intersects) = clipLineOriginalCurve(blah, blah, blah.....)

/**
**Objective-C:**

FBBezierCurveData clippedCurve = FBBezierCurveDataClipLineOriginalCurve(FBBezierCurveData me, FBBezierCurveData originalCurve, FBBezierCurveData curve, FBRange *originalRange, FBBezierCurveData otherCurve, BOOL *intersects)

**Becomes:**

let (clippedCurve, intersects) = clipLineOriginalCurve(blah, blah, blah.....)

- returns: **clippedCurve** - a curve clipped by another
- returns: **intersects** - a success flag
*/
private func clipLineOriginalCurve(_ originalCurve: FBBezierCurveData, curve: FBBezierCurveData, originalRange: inout FBRange, otherCurve: FBBezierCurveData) -> (clippedCurve: FBBezierCurveData, intersects: Bool)
{
  let themOnUs1 = FBParameterOfPointOnLine(curve.endPoint1, lineEnd: curve.endPoint2, point: otherCurve.endPoint1)
  let themOnUs2 = FBParameterOfPointOnLine(curve.endPoint1, lineEnd: curve.endPoint2, point: otherCurve.endPoint2)
  let clippedRange = FBRange(
    minimum: max(0.0, min(themOnUs1, themOnUs2)),
    maximum: min(1.0, max(themOnUs1, themOnUs2)))

  if clippedRange.minimum > clippedRange.maximum {
    return (curve, false)   // No intersection
  }

  // Right now the clipped range is relative to ourself, not the original curve,
  // so map the newly clipped range onto the original range.
  originalRange = FBRange(
    minimum: FBRangeScaleNormalizedValue(originalRange, value: clippedRange.minimum),
    maximum: FBRangeScaleNormalizedValue(originalRange, value: clippedRange.maximum))

  return (originalCurve.subcurveWithRange(originalRange) , true)
}

/*
func test(c1: FBBezierCurveData, c2: FBBezierCurveData, inout r: FBRange, c3: FBBezierCurveData) {
  clipLineOriginalCurve(c1, c2, &r, c3)
}
*/

// 796
// static BOOL FBBezierCurveDataCheckLinesForOverlap(FBBezierCurveData me, FBRange *usRange, FBRange *themRange, FBBezierCurveData originalUs, FBBezierCurveData originalThem, FBBezierCurveData *us, FBBezierCurveData *them)

/**
**Objective-C:**

BOOL overlaps = FBBezierCurveDataCheckLinesForOverlap(FBBezierCurveData me, FBRange *usRange, FBRange *themRange, FBBezierCurveData originalUs, FBBezierCurveData originalThem, FBBezierCurveData *us, FBBezierCurveData *them)

**Becomes:**

let overlaps = checkLinesForOverlap(blah, blah, blah.....)

*/
@discardableResult
private func checkLinesForOverlap(_ me: FBBezierCurveData, usRange: inout FBRange, themRange: inout FBRange, originalUs: FBBezierCurveData, originalThem: FBBezierCurveData, us: inout FBBezierCurveData, them: inout FBBezierCurveData) -> Bool
{
  // First see if its possible for them to overlap at all
  if !FBLineBoundsMightOverlap(us.bounds, bounds2: them.bounds) {
    return false
  }

  // Are all 4 points in a single line?
  let errorThreshold = isRunningOn64BitDevice ? 1e-7 : 1e-2

  let isColinear = FBAreValuesCloseWithOptions(
    CounterClockwiseTurn(us.endPoint1, point2: us.endPoint2, point3: them.endPoint1),
    value2: 0.0,
    threshold: errorThreshold)
    && FBAreValuesCloseWithOptions(
      CounterClockwiseTurn(us.endPoint1, point2: us.endPoint2, point3: them.endPoint2),
      value2: 0.0,
      threshold: errorThreshold)

  if !isColinear {
    return false
  }

  var intersects = false
  (us, intersects) = clipLineOriginalCurve(originalUs, curve: us, originalRange: &usRange, otherCurve: them)
  //    *us = FBBezierCurveDataClipLineOriginalCurve(me, originalUs, *us, usRange, *them, &intersects);
  if !intersects {
    return false
  }

  (them, intersects) = clipLineOriginalCurve(originalThem, curve: them, originalRange: &themRange, otherCurve: us)
  //    *them = FBBezierCurveDataClipLineOriginalCurve(me, originalThem, *them, themRange, *us, &intersects);

  return intersects
}


// 906
//static BOOL FBBezierCurveDataAreCurvesEqual(FBBezierCurveData me, FBBezierCurveData other)
private func curvesAreEqual(_ me: FBBezierCurveData, other: FBBezierCurveData) -> Bool
{
  if me.isPoint() || other.isPoint() {
    return false
  }

  if me.isStraightLine != other.isStraightLine {
    return false
  }

  let endPointThreshold = isRunningOn64BitDevice ? 1e-4 : 1e-2
  let controlPointThreshold = 1e-1

  if me.isStraightLine {
    return FBArePointsCloseWithOptions(me.endPoint1, point2: other.endPoint1, threshold: endPointThreshold) && FBArePointsCloseWithOptions(me.endPoint2, point2: other.endPoint2, threshold: endPointThreshold);
  }

  return FBArePointsCloseWithOptions(me.endPoint1, point2: other.endPoint1, threshold: endPointThreshold)
    && FBArePointsCloseWithOptions(me.controlPoint1, point2: other.controlPoint1, threshold: controlPointThreshold)
    && FBArePointsCloseWithOptions(me.controlPoint2, point2: other.controlPoint2, threshold: controlPointThreshold)
    && FBArePointsCloseWithOptions(me.endPoint2, point2: other.endPoint2, threshold: endPointThreshold);
}


// 926
//static BOOL FBBezierCurveDataIsEqual(FBBezierCurveData me, FBBezierCurveData other)
private func dataIsEqual(_ me: FBBezierCurveData, other: FBBezierCurveData) -> Bool
{
  // LRT - fiddle with these
  let threshold = isRunningOn64BitDevice ? 1e-10 : 1e-2
  return me.isEqualWithOptions(other, threshold: threshold)
}

// 931
//static FBBezierCurveData FBBezierCurveDataReversed(FBBezierCurveData me)
private func reversed(_ me: FBBezierCurveData) -> FBBezierCurveData
{
  return FBBezierCurveData(endPoint1: me.endPoint2, controlPoint1: me.controlPoint2, controlPoint2: me.controlPoint1, endPoint2: me.endPoint1, isStraightLine: me.isStraightLine)
}


// 936
// static BOOL FBBezierCurveDataCheckForOverlapRange(FBBezierCurveData me, FBBezierIntersectRange **intersectRange, FBRange *usRange, FBRange *themRange, FBBezierCurve* originalUs, FBBezierCurve* originalThem, FBBezierCurveData us, FBBezierCurveData them)
@discardableResult
private func checkForOverlapRange(_ me: FBBezierCurveData, intersectRange: inout FBBezierIntersectRange?, usRange: inout FBRange, themRange: inout FBRange, originalUs: FBBezierCurve, originalThem: FBBezierCurve, us: FBBezierCurveData, them: FBBezierCurveData) -> Bool
{
  if curvesAreEqual(us, other: them) {
    // TODO: Is this range not being sent back up to the inout parameter ?
    // LRT - 2015.08.07 07:00:33 PM
    // Verified that it definitely is setting the original inout var
    intersectRange = FBBezierIntersectRange(curve1: originalUs, parameterRange1: usRange, curve2:originalThem, parameterRange2: themRange, reversed: false)
    return true
  } else if curvesAreEqual(us, other: them.reversed()) {
    intersectRange = FBBezierIntersectRange(curve1: originalUs, parameterRange1: usRange, curve2:originalThem, parameterRange2: themRange, reversed: true)
    return true
  }

  return false
}

// 952
//static FBBezierCurveData FBBezierCurveDataFindPossibleOverlap(FBBezierCurveData me, FBBezierCurveData originalUs, FBBezierCurveData them, FBRange *possibleRange)
private func findPossibleOverlap(_ me: FBBezierCurveData, originalUs: FBBezierCurveData, them: FBBezierCurveData, possibleRange: inout FBRange) -> FBBezierCurveData
{
  let themOnUs1 = originalUs.closestLocationToPoint(them.endPoint1)
  let themOnUs2 = originalUs.closestLocationToPoint(them.endPoint2)
  let range = FBRange(
    minimum: min(themOnUs1.parameter, themOnUs2.parameter),
    maximum: max(themOnUs1.parameter, themOnUs2.parameter));

  possibleRange = range;

  return originalUs.subcurveWithRange(range)
}

// 961
//static BOOL FBBezierCurveDataCheckCurvesForOverlapRange(FBBezierCurveData me, FBBezierIntersectRange **intersectRange, FBRange *usRange, FBRange *themRange, FBBezierCurve* originalUs, FBBezierCurve* originalThem, FBBezierCurveData us, FBBezierCurveData them)
private func checkCurvesForOverlapRange(
  _ me: FBBezierCurveData,
  intersectRange: inout FBBezierIntersectRange?,
  usRange: inout FBRange,
  themRange: inout FBRange,
  originalUs: FBBezierCurve,
  originalThem: FBBezierCurve,
  us: FBBezierCurveData,
  them: FBBezierCurveData
  ) -> Bool
{
  if checkForOverlapRange(me, intersectRange: &intersectRange, usRange: &usRange, themRange: &themRange, originalUs: originalUs, originalThem: originalThem, us: us, them: them) {
    return true
  }

  var usSubcurveRange = FBRange(minimum: 0.0, maximum: 0.0)
  let usSubcurve = findPossibleOverlap(me, originalUs: originalUs.data, them: them, possibleRange: &usSubcurveRange)

  var themSubcurveRange = FBRange(minimum: 0.0, maximum: 0.0)
  let themSubcurve = findPossibleOverlap(me, originalUs: originalThem.data, them: us, possibleRange: &themSubcurveRange)

  let threshold = isRunningOn64BitDevice ? 1e-4 : 1e-2
  if usSubcurve.isEqualWithOptions(themSubcurve, threshold: threshold) || usSubcurve.isEqualWithOptions(reversed(themSubcurve), threshold: threshold) {
    usRange = usSubcurveRange
    themRange = themSubcurveRange

    return checkForOverlapRange(me, intersectRange: &intersectRange, usRange: &usRange, themRange: &themRange, originalUs: originalUs, originalThem: originalThem, us: usSubcurve, them: themSubcurve);
  }

  return false
}

// TODO: Was still working here

let FBBezierCurveDataInvalidLength = -1.0


// 982
//static void FBBezierCurveDataCheckNoIntersectionsForOverlapRange(FBBezierCurveData me, FBBezierIntersectRange **intersectRange, FBRange *usRange, FBRange *themRange, FBBezierCurve* originalUs, FBBezierCurve* originalThem, FBBezierCurveData us, FBBezierCurveData them, FBBezierCurveData nonpointUs, FBBezierCurveData nonpointThem)
private func checkNoIntersectionsForOverlapRange(
  _ me: FBBezierCurveData,
  intersectRange: inout FBBezierIntersectRange?,
  usRange: inout FBRange,
  themRange: inout FBRange,
  originalUs: FBBezierCurve,
  originalThem: FBBezierCurve,
  us: inout FBBezierCurveData,
  them: inout FBBezierCurveData,
  nonpointUs: FBBezierCurveData,
  nonpointThem: FBBezierCurveData
  )
{
  if us.isStraightLine && them.isStraightLine {
    checkLinesForOverlap(me, usRange: &usRange, themRange: &themRange, originalUs: originalUs.data, originalThem: originalThem.data, us: &us, them: &them)
  }

  checkForOverlapRange(me, intersectRange: &intersectRange, usRange: &usRange, themRange: &themRange, originalUs: originalUs, originalThem: originalThem, us: us, them: them)
}

// 990
//static BOOL FBBezierCurveDataCheckForStraightLineOverlap(FBBezierCurveData me, FBBezierIntersectRange **intersectRange, FBRange *usRange, FBRange *themRange, FBBezierCurve* originalUs, FBBezierCurve* originalThem, FBBezierCurveData us, FBBezierCurveData them, FBBezierCurveData nonpointUs, FBBezierCurveData nonpointThem)

private func straightLineOverlap(
  _ me: FBBezierCurveData,
  intersectRange: inout FBBezierIntersectRange?,
  usRange: inout FBRange,
  themRange: inout FBRange,
  originalUs: FBBezierCurve,
  originalThem: FBBezierCurve,
  us: inout FBBezierCurveData,
  them: inout FBBezierCurveData,
  nonpointUs: FBBezierCurveData,
  nonpointThem: FBBezierCurveData) -> Bool
{
  var hasOverlap = false

  if us.isStraightLine && them.isStraightLine {
    hasOverlap = checkLinesForOverlap(me, usRange: &usRange, themRange: &themRange, originalUs: originalUs.data, originalThem: originalThem.data, us: &us, them: &them)
  }

  if hasOverlap {
    hasOverlap = checkForOverlapRange(me, intersectRange: &intersectRange, usRange: &usRange, themRange: &themRange, originalUs: originalUs, originalThem: originalThem, us: us, them: them)
  }

  return hasOverlap
}

// 1003
//static CGFloat FBBezierCurveDataRefineParameter(FBBezierCurveData me, CGFloat parameter, NSPoint point)
private func pfRefineParameter(_ me: FBBezierCurveData, parameter: Double, point: CGPoint) -> Double
{
  // Use Newton's Method to refine our parameter. In general, that formula is:
  //
  //  parameter = parameter - f(parameter) / f'(parameter)
  //
  // In our case:
  //
  //  f(parameter) = (Q(parameter) - point) * Q'(parameter) = 0
  //
  // Where Q'(parameter) is tangent to the curve at Q(parameter) and orthogonal to [Q(parameter) - P]
  //
  // Taking the derivative gives us:
  //
  //  f'(parameter) = (Q(parameter) - point) * Q''(parameter) + Q'(parameter) * Q'(parameter)
  //

  var bezierPoints: [CGPoint] = [me.endPoint1, me.controlPoint1, me.controlPoint2, me.endPoint2]

  // Compute Q(parameter)
  let qAtParameter = BezierWithPoints(3, bezierPoints: bezierPoints, parameter: parameter, withCurves: false).point

  // Compute Q'(parameter)
  let qPrimePoints: [CGPoint] = [
    CGPoint(
      x:(bezierPoints[1].x - bezierPoints[0].x) * 3.0,
      y:(bezierPoints[1].y - bezierPoints[0].y) * 3.0
    ),
    CGPoint(
      x:(bezierPoints[2].x - bezierPoints[1].x) * 3.0,
      y:(bezierPoints[2].y - bezierPoints[1].y) * 3.0
    ),
    CGPoint(
      x:(bezierPoints[3].x - bezierPoints[2].x) * 3.0,
      y:(bezierPoints[3].y - bezierPoints[2].y) * 3.0
    )
  ]
  let qPrimeAtParameter = BezierWithPoints(2, bezierPoints: qPrimePoints, parameter: parameter, withCurves: false).point

  // Compute Q''(parameter)
  let qPrimePrimePoints: [CGPoint] = [
    CGPoint(
      x: (qPrimePoints[1].x - qPrimePoints[0].x) * 2.0,
      y: (qPrimePoints[1].y - qPrimePoints[0].y) * 2.0
    ),
    CGPoint(
      x: (qPrimePoints[2].x - qPrimePoints[1].x) * 2.0,
      y: (qPrimePoints[2].y - qPrimePoints[1].y) * 2.0
    )
  ]
  let qPrimePrimeAtParameter = BezierWithPoints(1, bezierPoints: qPrimePrimePoints, parameter: parameter, withCurves: false).point

  // Compute f(parameter) and f'(parameter)
  let qMinusPoint = FBSubtractPoint(qAtParameter, point2: point)
  let fAtParameter = FBDotMultiplyPoint(qMinusPoint, point2: qPrimeAtParameter)
  let fPrimeAtParameter = FBDotMultiplyPoint(qMinusPoint, point2: qPrimePrimeAtParameter) + FBDotMultiplyPoint(qPrimeAtParameter, point2: qPrimeAtParameter)

  // Newton's method!
  return parameter - (fAtParameter / fPrimeAtParameter)
}

// 1050
//static FBBezierIntersectRange *FBBezierCurveDataMergeIntersectRange(FBBezierIntersectRange *intersectRange, FBBezierIntersectRange *otherIntersectRange)
private func mergeIntersectRange(_ intersectRange: FBBezierIntersectRange?, otherIntersectRange: FBBezierIntersectRange?) -> FBBezierIntersectRange?
{
  if otherIntersectRange == nil {
    return intersectRange
  }

  if intersectRange == nil {
    return otherIntersectRange
  }

  intersectRange!.merge(otherIntersectRange!)

  return intersectRange
}


// 1063
//static BOOL FBBezierCurveDataIntersectionsWithStraightLines(FBBezierCurveData me, FBBezierCurveData curve, FBRange *usRange, FBRange *themRange, FBBezierCurve *originalUs, FBBezierCurve *originalThem, FBCurveIntersectionBlock outputBlock, BOOL *stop)
@discardableResult
private func intersectionsWithStraightLines(
  _ me: FBBezierCurveData,
  curve: FBBezierCurveData,
  usRange: inout FBRange,
  themRange: inout FBRange,
  originalUs: FBBezierCurve,
  originalThem: FBBezierCurve,
  stop: inout Bool,
  // TODO: Need to see if there's a better way to define a block type in Swift
  outputBlock: (_ intersect: FBBezierIntersection) -> (setStop: Bool, stopValue:Bool)
  //outputBlock: (FBBezierIntersection, Bool) -> Bool
  ) -> Bool
{
  if !me.isStraightLine || !curve.isStraightLine {
    return false
  }


  var intersectionPoint = CGPoint.zero
  let intersects = FBLinesIntersect(me.endPoint1, line1End: me.endPoint2, line2Start: curve.endPoint1, line2End: curve.endPoint2, outIntersect: &intersectionPoint)
  if !intersects {
    return false
  }

  let meParam = FBParameterOfPointOnLine(me.endPoint1, lineEnd: me.endPoint2, point: intersectionPoint)
  if FBIsValueLessThan(meParam, maximum: 0.0) || FBIsValueGreaterThan(meParam, minimum: 1.0) {
    return false
  }

  let curveParam = FBParameterOfPointOnLine(curve.endPoint1, lineEnd: curve.endPoint2, point: intersectionPoint)
  if FBIsValueLessThan(curveParam, maximum: 0.0) || FBIsValueGreaterThan(curveParam, minimum: 1.0) {
    return false
  }

  let intersect = FBBezierIntersection(curve1: originalUs, param1:meParam, curve2:originalThem, param2:curveParam)

  let stopResults = outputBlock(intersect)
  if stopResults.setStop {
    stop = stopResults.stopValue
  }

  return true
}


// ========================================================
// MARK: ---- MAIN SPLIT FUNCTION ----
// ========================================================

// 1086
//static void FBBezierCurveDataIntersectionsWithBezierCurve(FBBezierCurveData me, FBBezierCurveData curve, FBRange *usRange, FBRange *themRange, FBBezierCurve *originalUs, FBBezierCurve *originalThem, FBBezierIntersectRange **intersectRange, NSUInteger depth, FBCurveIntersectionBlock outputBlock, BOOL *stop)
internal func pfIntersectionsWithBezierCurve(
  _ me: FBBezierCurveData,
  curve: FBBezierCurveData,
  usRange: inout FBRange,
  themRange: inout FBRange,
  originalUs: FBBezierCurve,
  originalThem: FBBezierCurve,
  intersectRange: inout FBBezierIntersectRange?,
  depth: Int,
  stop: inout Bool,
  outputBlock: (_ intersect: FBBezierIntersection) -> (setStop: Bool, stopValue:Bool))
  //outputBlock: (FBBezierIntersection, Bool) -> (Bool))
{
  // This is the main work loop.
  // At a high level this method sits in a loop and removes sections (ranges)
  // of the two bezier curves that it knows don't intersect.
  // (how it knows that is covered in the appropriate method).
  // The idea is to whittle the curves down to the point where they do intersect.
  //
  // When the range where they intersect converges (i.e. matches to 6 decimal places)
  // or there are more than 500 attempts, the loop stops.
  //
  // A special case is when we're not able to remove at least 20% of
  // the curves on a given interation.
  // In that case we assume there are likely multiple intersections, so we
  // divide one of curves in half, and recurse on the two halves.

  let places = 6 // How many decimals place to calculate the solution out to
  let maxIterations = 500 // how many iterations to allow before we just give up
  let maxDepth = 10 // how many recursive calls to allow before we just give up
  let minimumChangeNeeded = 0.20 // how much to clip off for a given iteration minimum before we subdivide the curve

  var us = FBBezierCurveData(cloning: me)
  // us is self, but will become clipped down to where the intersection is (perhaps)

  var them = FBBezierCurveData(cloning: curve)
  // them is the other curve we're intersecting with, but clipped down to where the intersection is

  var nonpointUs = FBBezierCurveData(cloning: us)
  var nonpointThem = FBBezierCurveData(cloning: them)


  // Horizontal and vertical lines are somewhat special cases,
  // and the math doesn't always work out that great.
  // For example, two vertical lines that overlap will kick out
  // as intersecting at the endpoints.
  //
  // Try to detect that kind of overlap at the start.
  if straightLineOverlap(me, intersectRange: &intersectRange, usRange: &usRange, themRange: &themRange, originalUs: originalUs, originalThem: originalThem, us: &us, them: &them, nonpointUs: nonpointUs, nonpointThem: nonpointThem) {
    return
  }

  if us.isStraightLine && them.isStraightLine {
    intersectionsWithStraightLines(me, curve: curve, usRange: &usRange, themRange: &themRange, originalUs: originalUs, originalThem: originalThem, stop: &stop, outputBlock: outputBlock)
    return
  }

  var originalUsData = FBBezierCurveData(cloning: originalUs.data)
  var originalThemData = FBBezierCurveData(cloning: originalThem.data)

  // Don't check for convergence until we actually see if we intersect or not.
  // i.e. Make sure we go through at least once, otherwise the results don't mean anything.
  //
  // Be sure to stop as soon as either range converges, otherwise calculations
  // for the other range goes funky because one curve is essentially a point.
  var iterations = 0
  var hadConverged = true

  while ( iterations < maxIterations && ((iterations == 0) || (!FBRangeHasConverged(usRange, decimalPlaces: places) || !FBRangeHasConverged(themRange, decimalPlaces: places))) ) {

    // Remember what the current range is so we can calculate how much it changed later
    let previousUsRange = usRange
    let previousThemRange = themRange

    // Remove the range from ourselves that doesn't intersect with them.
    // If the other curve is already a point, use the previous iteration's
    //  copy of them so calculations still work.
    var intersects = false
    if !them.isPoint() {
      nonpointThem = them
    }
    (us, intersects) = bezierClipWithBezierCurve(nonpointUs, curve: nonpointThem, originalCurve: &originalUsData, originalRange: &usRange);
    if !intersects {
      checkNoIntersectionsForOverlapRange(me, intersectRange: &intersectRange, usRange: &usRange, themRange: &themRange, originalUs: originalUs, originalThem: originalThem, us: &us, them: &them, nonpointUs: nonpointUs, nonpointThem: nonpointThem)
      return  // If they don't intersect at all stop now
    }
    if iterations > 0 && (us.isPoint() || them.isPoint())
    {
      break
    }

    // Remove the range of them that doesn't intersect with us
    if !us.isPoint() {
      nonpointUs = us
    }
    else if iterations == 0 {
      // If the first time through, "us" was reduced to a point, then we're never
      // going to know if the curves actually intersect, even if both ranges converge.
      //
      // The ranges can converge on the parameters on each respective curve that is
      // closest to the other. But without being clipped to a smaller range,
      // the algorithm won't necessarily detect that they don't actually intersect
      hadConverged = false
    }

    (them, intersects) = bezierClipWithBezierCurve(nonpointThem, curve: nonpointUs, originalCurve: &originalThemData, originalRange: &themRange)
    if !intersects {
      checkNoIntersectionsForOverlapRange(me, intersectRange: &intersectRange, usRange: &usRange, themRange: &themRange, originalUs: originalUs, originalThem: originalThem, us: &us, them: &them, nonpointUs: nonpointUs, nonpointThem: nonpointThem)
      return  // If they don't intersect at all stop now
    }
    if iterations > 0 && (us.isPoint() || them.isPoint())
    {
      break
    }

    // See if either of curves ranges is reduced by less than 20%.
    let percentChangeInUs = (FBRangeGetSize(previousUsRange) - FBRangeGetSize(usRange)) / FBRangeGetSize(previousUsRange)
    let percentChangeInThem = (FBRangeGetSize(previousThemRange) - FBRangeGetSize(themRange)) / FBRangeGetSize(previousThemRange)

    var didNotSplit = false

    if percentChangeInUs < minimumChangeNeeded && percentChangeInThem < minimumChangeNeeded {
      // We're not converging fast enough, likely because there are
      // multiple intersections here.

      // Or the curves are the same, check for that first.
      if checkCurvesForOverlapRange(me, intersectRange: &intersectRange, usRange: &usRange, themRange: &themRange, originalUs: originalUs, originalThem: originalThem, us: us, them: them) {
        return
      }

      // Divide and conquer. Divide the longer curve in half, and recurse
      if FBRangeGetSize(usRange) > FBRangeGetSize(themRange) {
        // Since our remaining range is longer, split the remains of us in half at the midway point
        var usRange1 = FBRange(
          minimum: usRange.minimum,
          maximum: (usRange.minimum + usRange.maximum) / 2.0)
        let us1 = originalUsData.subcurveWithRange(usRange1)
        var themRangeCopy1 = themRange  // make a local copy because it'll get modified when we recurse

        var usRange2 = FBRange(
          minimum: (usRange.minimum + usRange.maximum) / 2.0,
          maximum: usRange.maximum)
        let us2 = originalUsData.subcurveWithRange(usRange2)
        var themRangeCopy2 = themRange  // make a local copy because it'll get modified when we recurse

        let range1ConvergedAlready = FBRangeHasConverged(usRange1, decimalPlaces: places) && FBRangeHasConverged(themRange, decimalPlaces: places)
        let range2ConvergedAlready = FBRangeHasConverged(usRange2, decimalPlaces: places) && FBRangeHasConverged(themRange, decimalPlaces: places);

        if !range1ConvergedAlready && !range2ConvergedAlready && depth < maxDepth {
          // Compute the intersections between the two halves of us and them
          var leftIntersectRange : FBBezierIntersectRange? // = nil
          pfIntersectionsWithBezierCurve(us1, curve: them, usRange: &usRange1, themRange: &themRangeCopy1, originalUs: originalUs, originalThem: originalThem, intersectRange: &leftIntersectRange, depth: depth + 1, stop: &stop, outputBlock: outputBlock)

          intersectRange = mergeIntersectRange(intersectRange, otherIntersectRange: leftIntersectRange)

          if stop {
            return
          }

          var rightIntersectRange : FBBezierIntersectRange? // = nil
          pfIntersectionsWithBezierCurve(us2, curve: them, usRange: &usRange2, themRange: &themRangeCopy2, originalUs: originalUs, originalThem: originalThem, intersectRange: &rightIntersectRange, depth: depth + 1, stop: &stop, outputBlock: outputBlock);

          intersectRange = mergeIntersectRange(intersectRange, otherIntersectRange: rightIntersectRange)

          return
        } else {
          didNotSplit = true
        }
      }
      else
      {
        // Since their remaining range is longer, split the
        // remains of them in half at the midway point
        var themRange1 = FBRange(
          minimum: themRange.minimum,
          maximum: (themRange.minimum + themRange.maximum) / 2.0)
        let them1 = originalThemData.subcurveWithRange(themRange1)
        var usRangeCopy1 = usRange  // make a local copy because it'll get modified when we recurse

        var themRange2 = FBRange(
          minimum: (themRange.minimum + themRange.maximum) / 2.0,
          maximum: themRange.maximum)
        let them2 = originalThemData.subcurveWithRange(themRange2)
        var usRangeCopy2 = usRange  // make a local copy because it'll get modified when we recurse

        let range1ConvergedAlready = FBRangeHasConverged(themRange1, decimalPlaces: places) && FBRangeHasConverged(usRange, decimalPlaces: places)
        let range2ConvergedAlready = FBRangeHasConverged(themRange2, decimalPlaces: places) && FBRangeHasConverged(usRange, decimalPlaces: places)

        if !range1ConvergedAlready && !range2ConvergedAlready && depth < maxDepth {
          // Compute the intersections between the two halves of them and us
          var leftIntersectRange : FBBezierIntersectRange? // = nil
          pfIntersectionsWithBezierCurve(us, curve: them1, usRange: &usRangeCopy1, themRange: &themRange1, originalUs: originalUs, originalThem: originalThem, intersectRange: &leftIntersectRange, depth: depth + 1, stop: &stop, outputBlock: outputBlock)

          intersectRange = mergeIntersectRange(intersectRange, otherIntersectRange: leftIntersectRange)

          if stop {
            return
          }

          var rightIntersectRange : FBBezierIntersectRange? // = nil
          pfIntersectionsWithBezierCurve(us, curve: them2, usRange: &usRangeCopy2, themRange: &themRange2, originalUs: originalUs, originalThem: originalThem, intersectRange: &rightIntersectRange, depth: depth + 1, stop: &stop, outputBlock: outputBlock)

          intersectRange = mergeIntersectRange(intersectRange, otherIntersectRange: rightIntersectRange)

          return
        } else {
          didNotSplit = true
        }
      }

      if didNotSplit && (FBRangeGetSize(previousUsRange) - FBRangeGetSize(usRange)) == 0 && (FBRangeGetSize(previousThemRange) - FBRangeGetSize(themRange)) == 0 {
        // We're not converging at _all_ and we can't split, so we need to bail out.
        return // no intersections
      }
    }

    iterations += 1
  }


  // It's possible that one of the curves has converged, but the other hasn't.
  // Since the math becomes wonky once a curve becomes a point, the loop stops
  // as soon as either curve converges.
  //
  // However for our purposes we need _both_ curves to converge; that is to say
  // we need the parameter for each curve where they intersect.
  // Fortunately, since one curve did converge we know the 2D point where they
  // converge, plus we have a reasonable approximation for the parameter for
  // the curve that didn't.
  // That means we can use Newton's method to refine the parameter of the curve
  // that didn't converge.

  if !FBRangeHasConverged(usRange, decimalPlaces: places) || !FBRangeHasConverged(themRange, decimalPlaces: places) {
    // Maybe there's an overlap in here?
    if checkCurvesForOverlapRange(me, intersectRange: &intersectRange, usRange: &usRange, themRange: &themRange, originalUs: originalUs, originalThem: originalThem, us: originalUsData, them: originalThemData) {
      return
    }

    // We bail out of the main loop as soon as we know things intersect, but before
    // the math falls apart. Unfortunately sometimes this means we don't always get
    // the best estimate of the parameters.
    //
    // Below we fall back to Netwon's method, but it's accuracy is dependant on our
    // previous calculations.
    //
    // So here assume things intersect and just try to tighten up the parameters.
    // If the math falls apart because everything's a point, that's OK since we
    // already have a "reasonable" estimation of the parameters.

    refineIntersectionsOverIterations(3, usRange: &usRange, themRange: &themRange, originalUs: &originalUsData, originalThem: &originalThemData, us: &us, them: &them, nonpointUs: &nonpointUs, nonpointThem: &nonpointThem)

    // Sometimes we need a little more precision. Be careful though, because
    // in some cases trying for more makes the math fall apart.

    if !FBRangeHasConverged(usRange, decimalPlaces: places) || !FBRangeHasConverged(themRange, decimalPlaces: places) {
      refineIntersectionsOverIterations(4, usRange: &usRange, themRange: &themRange, originalUs: &originalUsData, originalThem: &originalThemData, us: &us, them: &them, nonpointUs: &nonpointUs, nonpointThem: &nonpointThem)
    }
  }

  if FBRangeHasConverged(usRange, decimalPlaces: places) && !FBRangeHasConverged(themRange, decimalPlaces: places) {
    // Refine the them range since it didn't converge
    let intersectionPoint = originalUsData.pointAtParameter(FBRangeAverage(usRange)).point

    // Although the range didn't converge, it should be a reasonable
    // approximation which is all Newton needs
    var refinedParameter = FBRangeAverage(themRange)
    for _ in 0 ..< 3 {
      refinedParameter = pfRefineParameter(originalThemData, parameter: refinedParameter, point: intersectionPoint)
      refinedParameter = min(themRange.maximum, max(themRange.minimum, refinedParameter))
    }
    themRange.minimum = refinedParameter
    themRange.maximum = refinedParameter
    hadConverged = false
  }
  else if !FBRangeHasConverged(usRange, decimalPlaces: places) && FBRangeHasConverged(themRange, decimalPlaces: places) {
    // Refine the us range since it didn't converge
    let intersectionPoint = originalThemData.pointAtParameter(FBRangeAverage(themRange)).point

    // Although the range didn't converge, it should be a reasonable
    // approximation which is all Newton needs
    var refinedParameter = FBRangeAverage(usRange)
    for _ in 0 ..< 3 {
      refinedParameter = pfRefineParameter(originalUsData, parameter: refinedParameter, point: intersectionPoint)
      refinedParameter = min(usRange.maximum, max(usRange.minimum, refinedParameter))
    }
    usRange.minimum = refinedParameter
    usRange.maximum = refinedParameter
    hadConverged = false
  }

  // If it never converged and we stopped because of our loop max,
  // assume overlap or something else. Bail.
  if (!FBRangeHasConverged(usRange, decimalPlaces: places) || !FBRangeHasConverged(themRange, decimalPlaces: places)) && iterations >= maxIterations {
    checkForOverlapRange(me, intersectRange: &intersectRange, usRange: &usRange, themRange: &themRange, originalUs: originalUs, originalThem: originalThem, us: us, them: them)

    return
  }

  if !hadConverged {
    // Since one of them didn't converge, we need to make sure they actually intersect.
    // Compute the point from both and compare
    let intersectionPoint = originalUsData.pointAtParameter(FBRangeAverage(usRange)).point
    let checkPoint = originalThemData.pointAtParameter(FBRangeAverage(themRange)).point
    let threshold = isRunningOn64BitDevice ? 1e-3 : 1e-1
    if !FBArePointsCloseWithOptions(intersectionPoint, point2: checkPoint, threshold: threshold) {
      return
    }
  }

  // Return the final intersection, which we represent by the original curves
  // and the parameters where they intersect.
  //
  // The parameter values are useful later in the boolean operations,
  // plus it allows us to do lazy calculations.
  let intersection = FBBezierIntersection(curve1: originalUs, param1: FBRangeAverage(usRange), curve2:originalThem, param2: FBRangeAverage(themRange))

  let stopResults = outputBlock(intersection)
  if stopResults.setStop {
    stop = stopResults.stopValue
  }
}





// ========================================================
// MARK: ---- FBBezierCurve ----
// ========================================================


//////////////////////////////////////////////////////////////////////////////////
// FBBezierCurve
//
// The main purpose of this class is to compute the intersections of two bezier
//  curves. It does this using the bezier clipping algorithm, described in
//  "Curve intersection using Bezier clipping" by TW Sederberg and T Nishita.
//  http://cagd.cs.byu.edu/~tom/papers/bezclip.pdf
//

func ==(lhs: FBBezierCurve, rhs: FBBezierCurve) -> Bool {
  return dataIsEqual(lhs.data, other: rhs.data)
}

class FBBezierCurve : CustomDebugStringConvertible, CustomStringConvertible, Equatable {

  // MARK: edge extensions

  fileprivate var _startShared = false
  fileprivate var _contour: FBBezierContour?
  fileprivate var _index: Int = 0
  var crossings: [FBEdgeCrossing] = []

  // 89 of Edge extension
  var index : Int {
    get {
      return _index
    }
    set {
      _index = newValue
    }
  }

  // 99 of Edge extension
  var isStartShared : Bool {
    return _startShared
  }

  var startShared : Bool {
    get {
      return _startShared
    }
    set {
      _startShared = newValue
    }
  }

  // 109 of Edge extension
  var contour : FBBezierContour? {
    get {
      return _contour
    }
    set {
      _contour = newValue
    }
  }

  // An easy way to iterate all the edges. Wraps around.
  //var next: FBBezierCurve
  //var previous: FBBezierCurve
  //var nextNonpoint: FBBezierCurve
  //var previousNonpoint: FBBezierCurve

  //var firstCrossing: FBEdgeCrossing
  //var lastCrossing: FBEdgeCrossing

  //var hasCrossings = false

  //var firstNonselfCrossing: FBEdgeCrossing
  //var lastNonselfCrossing: FBEdgeCrossing

  //var hasNonselfCrossings = false

  // MARK: standard class
  fileprivate var _data : FBBezierCurveData

  var data : FBBezierCurveData {
    get {
      return _data
    }
  }

  //  NSMutableArray *_crossings; // sorted by parameter of the intersection
//  FBBezierContour *_contour;
//  NSUInteger _index;
//  BOOL _startShared;


  // =======================
  // initWithEndPoint1:
  //
  //  (endPoint1: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint, endPoint2: CGPoint, contour: FBBezierContour!)
  init(endPoint1: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint, endPoint2: CGPoint) {

    _data = FBBezierCurveData(
      endPoint1: endPoint1,
      controlPoint1: controlPoint1,
      controlPoint2: controlPoint2,
      endPoint2: endPoint2,
      isStraightLine: false)
  }


  // =======================
  // initWithLineStartPoint:
  //
  //  (startPoint: CGPoint, endPoint: CGPoint, contour:FBBezierContour)
  init(startPoint: CGPoint, endPoint: CGPoint) {

    // Convert the line into a bezier curve to keep our intersection algorithm general (i.e. only
    //  has to deal with curves, not lines). As long as the control points are colinear with the
    //  end points, it'll be a line. But for consistency sake, we put the control points inside
    //  the end points, 1/3 of the total distance away from their respective end point.
    let distance = FBDistanceBetweenPoints(startPoint, point2: endPoint)
    let leftTangent = FBNormalizePoint(FBSubtractPoint(endPoint, point2: startPoint))

    _data = FBBezierCurveData(
      endPoint1: startPoint,
      controlPoint1: FBAddPoint(startPoint, point2: FBUnitScalePoint(leftTangent, scale: distance / 3.0)),
      controlPoint2: FBAddPoint(startPoint, point2: FBUnitScalePoint(leftTangent, scale: 2.0 * distance / 3.0)),
      endPoint2: endPoint,
      isStraightLine: true)

    //_contour = contour; // no cyclical references
  }

  // =======================
  // initWithBezierCurveData:
  //
  init(curveData: FBBezierCurveData)
  {
    _data = curveData;
  }

  //@synthesize data=_data;

  //private(set) var data : FBBezierCurveData

  var endPoint1 : CGPoint {
    get {
      return _data.endPoint1
    }
  }

  var endPoint2 : CGPoint {
    get {
      return _data.endPoint2
    }
  }

  var controlPoint1 : CGPoint {
    get {
      return _data.controlPoint1
    }
  }

  var controlPoint2 : CGPoint {
    get {
      return _data.controlPoint2
    }
  }

  var isStraightLine : Bool {
    get {
      return _data.isStraightLine
    }
  }

  // 1336
  class func bezierCurvesFromBezierPath(_ path: UIBezierPath!) -> [FBBezierCurve] {
    // Helper method to easily convert a bezier path into an array of FBBezierCurves.
    // Very straight-forward, only lines are a special case.

    var startPoint : CGPoint?

    let bezier = LRTBezierPathWrapper(path)
    var bezierCurves : [FBBezierCurve] = []

    var previousPoint = CGPoint.zero

    for item in bezier.elements {

      switch item {

      case let .move(v):
        previousPoint = v
        startPoint = v

      case let .line(v):
        // Convert lines to bezier curves as well.
        // Just set control point to be in the line formed by the end points
        bezierCurves.append(FBBezierCurve(startPoint: previousPoint, endPoint: v))
        previousPoint = v

      case .quadCurve(let to, let cp):
        let ⅔ : CGFloat = 2.0 / 3.0

        // lastPoint + twoThirds * (via - lastPoint)
        let cp1 = FBAddPoint(previousPoint, point2: FBScalePoint(FBSubtractPoint(cp, point2: previousPoint), scale: ⅔))
        // toPt + twoThirds * (via - toPt)
        let cp2 = FBAddPoint(to, point2: FBScalePoint(FBSubtractPoint(cp, point2: to), scale: ⅔))

        bezierCurves.append(FBBezierCurve(endPoint1: previousPoint, controlPoint1: cp1, controlPoint2: cp2, endPoint2: to))
        previousPoint = to

      case .cubicCurve(let to, let v1, let v2):
        bezierCurves.append(FBBezierCurve(endPoint1: previousPoint, controlPoint1: v1, controlPoint2: v2, endPoint2: to))
        previousPoint = to

      case .close:
        // Create a line back to the start if required
        if let startPoint = startPoint {
          if !previousPoint.equalTo(startPoint) {
            bezierCurves.append(FBBezierCurve(startPoint: previousPoint, endPoint: startPoint))
          }
        }
        startPoint = nil
        previousPoint = CGPoint.zero
      }
    }

    return bezierCurves
  }

  // 1376
  class func bezierCurveWithLineStartPoint(_ startPoint: CGPoint, endPoint: CGPoint) -> FBBezierCurve
  {
    return FBBezierCurve(startPoint: startPoint, endPoint: endPoint)
  }

  // 1381
  class func bezierCurveWithEndPoint1(_ endPoint1: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint, endPoint2: CGPoint) -> FBBezierCurve
  {
    return FBBezierCurve(endPoint1: endPoint1, controlPoint1: controlPoint1, controlPoint2: controlPoint2, endPoint2: endPoint2)
  }

  // 1386
  class func bezierCurveWithBezierCurveData(_ data: FBBezierCurveData) -> FBBezierCurve
  {
    return FBBezierCurve(curveData: data)
  }

  // 1391
  //- (id) initWithBezierCurveData:(FBBezierCurveData)data
  // see:
  // init(curveData: FBBezierCurveData)

  // 1400
  //- (id) initWithEndPoint1:(NSPoint)endPoint1 controlPoint1:(NSPoint)controlPoint1 controlPoint2:(NSPoint)controlPoint2 endPoint2:(NSPoint)endPoint2 contour:(FBBezierContour *)contour
  // see:
  // init(endPoint1: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint, endPoint2: CGPoint)

  // 1412
  //- (id) initWithLineStartPoint:(NSPoint)startPoint endPoint:(NSPoint)endPoint contour:(FBBezierContour *)contour
  // see:
  // init(startPoint: CGPoint, endPoint: CGPoint)


  // 1438
  func isEqual(_ object: AnyObject) -> Bool
  {
    if let other = object as? FBBezierCurve {
      return dataIsEqual(_data, other: other._data)
    } else {
      return false
    }
  }

  // 1447
  func doesHaveIntersectionsWithBezierCurve(_ curve: FBBezierCurve) -> Bool
  {
    // (intersect: FBBezierIntersection) -> (setStop: Bool, stopValue:Bool)
    var count = 0
    var unusedRange: FBBezierIntersectRange?

    intersectionsWithBezierCurve(curve, overlapRange: &unusedRange) {
      (intersect: FBBezierIntersection) -> (setStop: Bool, stopValue:Bool) in
      count += 1
      return (setStop:true, stopValue:true) // Only need the one
    }

    return count > 0;
  }

  // 1457
  //- (void) intersectionsWithBezierCurve:(FBBezierCurve *)curve overlapRange:(FBBezierIntersectRange **)intersectRange withBlock:(FBCurveIntersectionBlock)block
  func intersectionsWithBezierCurve(_ curve: FBBezierCurve, overlapRange: inout FBBezierIntersectRange?,
    withBlock block : (_ intersect: FBBezierIntersection) -> (setStop: Bool, stopValue:Bool))
  {
    // For performance reasons, do a quick bounds check to see if these even might intersect
    if !FBLineBoundsMightOverlap(_data.boundingRect, bounds2: curve._data.boundingRect) {
      return
    }

    if !FBLineBoundsMightOverlap(_data.bounds, bounds2: curve._data.bounds) {
      return
    }

    var usRange = FBRange(minimum: 0, maximum: 1)
    var themRange = FBRange(minimum: 0, maximum: 1)
    var stop = false
    pfIntersectionsWithBezierCurve(_data, curve: curve.data, usRange: &usRange, themRange: &themRange, originalUs: self, originalThem: curve, intersectRange: &overlapRange, depth: 0, stop: &stop, outputBlock: block)
  }

  // 1473
  //- (FBBezierCurve *) subcurveWithRange:(FBRange)range
  func subcurveWithRange(_ range: FBRange) -> FBBezierCurve {
    return FBBezierCurve(curveData: _data.subcurveWithRange(range))
  }

  // 1478
  //- (void) splitSubcurvesWithRange:(FBRange)range left:(FBBezierCurve **)leftCurve middle:(FBBezierCurve **)middleCurve right:(FBBezierCurve **)rightCurve
  func splitSubcurvesWithRange(_ range: FBRange, left: Bool, middle: Bool, right: Bool) -> (left: FBBezierCurve?, mid: FBBezierCurve?, right: FBBezierCurve?) {
    // Return a bezier curve representing the parameter range specified.
    // We do this by splitting twice:
    //   once on the minimum, then splitting the result of that on the maximum.

    var leftResult: FBBezierCurve?
    var midResult: FBBezierCurve?
    var rightResult: FBBezierCurve?

    // Start with the left side curve
    var remainingCurve: FBBezierCurveData?
    if range.minimum == 0.0 {
      remainingCurve = _data
      if left {
        // no need to set an optional to nil
        //*leftCurve = nil;
      }
    } else {
      var leftCurveData: FBBezierCurveData?
      let pap = _data.pointAtParameter(range.minimum)
      leftCurveData = pap.leftCurve
      remainingCurve = pap.rightCurve
      if left {
        if let leftCurveData = leftCurveData {
          leftResult = FBBezierCurve(curveData: leftCurveData)
        }
      }
    }

    // Special case  where we start at the end
    if range.minimum == 1.0 {
      if middle {
        if let remainingCurve = remainingCurve {
          midResult = FBBezierCurve(curveData: remainingCurve)
        }
      }
      // and leave the right optional as nil
      if right {
        // no need to set an optional to nil
        //*rightCurve = nil;
      }
    } else if let remainingCurve = remainingCurve {
      // We need to adjust the maximum parameter to
      // fit on the new curve before we split again
      let adjustedMaximum = (range.maximum - range.minimum) / (1.0 - range.minimum)

      let pap = remainingCurve.pointAtParameter(adjustedMaximum)

      if middle {
        if let curveData = pap.leftCurve {
          midResult = FBBezierCurve(curveData: curveData)
        }
      }

      if right {
        if let curveData = pap.rightCurve {
          rightResult = FBBezierCurve(curveData: curveData)
        }
      }
    }

    return (left: leftResult, mid: midResult, right: rightResult)
  }

  // 1516
  //- (FBBezierCurve *) reversedCurve
  func reversedCurve() -> FBBezierCurve {
    return FBBezierCurve(curveData: reversed(_data))
  }

  // 1521
  //- (NSPoint) pointAtParameter:(CGFloat)parameter leftBezierCurve:(FBBezierCurve **)leftBezierCurve rightBezierCurve:(FBBezierCurve **)rightBezierCurve
  func pointAtParameter(_ parameter: Double) -> (point: CGPoint, leftBezierCurve: FBBezierCurve?, rightBezierCurve: FBBezierCurve?) {

    var leftBezierCurve: FBBezierCurve?
    var rightBezierCurve: FBBezierCurve?

    let pap = _data.pointAtParameter(parameter)
    if let leftData = pap.leftCurve {
      leftBezierCurve = FBBezierCurve(curveData: leftData)
    }
    if let rightData = pap.rightCurve {
      rightBezierCurve = FBBezierCurve(curveData: rightData)
    }
    return (point: pap.point, leftBezierCurve: leftBezierCurve, rightBezierCurve: rightBezierCurve)
  }

  // 1535
  //- (CGFloat) refineParameter:(CGFloat)parameter forPoint:(NSPoint)point
  fileprivate func refineParameter(_ parameter: Double, forPoint point: CGPoint) -> Double {
    return pfRefineParameter(self.data, parameter: parameter, point: point)
  }

  // 1540
  //- (CGFloat) length
  func length() -> Double {
    return _data.getLength()
  }

  // 1545
  //- (CGFloat) lengthAtParameter:(CGFloat)parameter
  func lengthAtParameter(_ parameter: Double) -> Double {
    return _data.getLengthAtParameter(parameter)
  }

  // 1550
  //- (BOOL) isPoint
  //func isPoint() -> Bool {
  var isPoint : Bool {
    return _data.isPoint()
  }

  // 1555
  //- (FBBezierCurveLocation) closestLocationToPoint:(NSPoint)point
  func closestLocationToPoint(_ point: CGPoint) -> FBBezierCurveLocation {
    return _data.closestLocationToPoint(point)
  }

  // 1560
  //- (NSRect) bounds
  var bounds : CGRect {
    return _data.bounds
  }

  // 1565
  //- (NSRect) boundingRect
  var boundingRect : CGRect {
    return _data.boundingRect
  }

  // 1570
  //- (NSPoint) pointFromRightOffset:(CGFloat)offset
  func pointFromRightOffset(_ offset: Double) -> CGPoint
  {
    var offset = offset
    let len = length()
    offset = min(offset, len)
    let time = 1.0 - (offset / len)
    return _data.pointAtParameter(time).point
  }

  // 1578
  //- (NSPoint) pointFromLeftOffset:(CGFloat)offset
  func pointFromLeftOffset(_ offset: Double) -> CGPoint
  {
    var offset = offset
    let len = length()
    offset = min(offset, len)
    let time = offset / len
    return _data.pointAtParameter(time).point
  }

  // 1586
  //- (NSPoint) tangentFromRightOffset:(CGFloat)offset
  func tangentFromRightOffset(_ offset: Double) -> CGPoint
  {
    var offset = offset
    if _data.isStraightLine && !_data.isPoint() {
      return FBSubtractPoint(_data.endPoint1, point2: _data.endPoint2)
    }

    if offset == 0.0 && !_data.controlPoint2.equalTo(_data.endPoint2) {
      return FBSubtractPoint(_data.controlPoint2, point2: _data.endPoint2)
    } else {
      let len = length()
      if offset == 0.0 {
        offset = min(1.0, len)
      }
      let time = 1.0 - (offset / len)
      let pap = _data.pointAtParameter(time)
      if let curve = pap.leftCurve {
        return FBSubtractPoint(curve.controlPoint2, point2: curve.endPoint2)
      }
    }
    
    return CGPoint.zero  // nothing else worked!
  }

  // 1607
  //- (NSPoint) tangentFromLeftOffset:(CGFloat)offset
  func tangentFromLeftOffset(_ offset: Double) -> CGPoint
  {
    var offset = offset
    if _data.isStraightLine && !_data.isPoint() {
      return FBSubtractPoint(_data.endPoint2, point2: _data.endPoint1)
    }

    if offset == 0.0 && !_data.controlPoint1.equalTo(_data.endPoint1) {
      return FBSubtractPoint(_data.controlPoint1, point2: _data.endPoint1)
    } else {
      let len = length()
      if offset == 0.0 {
        offset = min(1.0, len)
      }
      let time = offset / len
      let pap = _data.pointAtParameter(time)
      if let curve = pap.rightCurve {
        return FBSubtractPoint(curve.controlPoint2, point2: curve.endPoint2)
      }
    }

    return CGPoint.zero  // nothing else worked!
  }

  // 1628
  //- (NSBezierPath *) bezierPath
  var bezierPath : UIBezierPath
  {
    let path = UIBezierPath()
    path.move(to: endPoint1)
    path.addCurve(to: endPoint2, controlPoint1: controlPoint1, controlPoint2: controlPoint2)
    return path
  }

  // 1636
  //- (FBBezierCurve *) clone
  func clone() -> FBBezierCurve
  {
    return FBBezierCurve(curveData: _data)
  }


  // For debug and printing
  var description : String {return "<\(_data.endPoint1.x), \(_data.endPoint1.y), \(_data.controlPoint1.x), \(_data.controlPoint1.y), \(_data.controlPoint2.x), \(_data.controlPoint2.y), \(_data.endPoint2.x), \(_data.endPoint2.y)>"}

  var debugDescription : String { return String(format: "<FBBezierCurve (%.18f, %.18f)-[%.18f, %.18f] curve to [%.18f, %.18f]-(%.18f, %.18f)>",
    _data.endPoint1.x, _data.endPoint1.y, _data.controlPoint1.x, _data.controlPoint1.y,
    _data.controlPoint2.x, _data.controlPoint2.y, _data.endPoint2.x, _data.endPoint2.y)
  }

}


